{
  "hash": "00567a3679962932627de3cb68d0ab4a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Encode\nauthor: Prof. Calvin\nsubtitle: \"Week 0x2\"\ninstitute: Crypto\nformat: \n    revealjs: \n        code-fold: false\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n\nexecute:\n    echo: true\n    cache: true\n    freeze: true  ## never re-render during project render\n---\n\n\n## Announcements\n\n- **Welcome** to CS 276\n- Desynced Lecture\n    - No Class Thursday, 30 Jan\n\n## Today\n\n- Encoding\n    -   Endianness\n    -   Casts\n    -   Two's Complement\n\n# Endianness\n\n## \"Good at\"\n\n- Computers \"are good at\" storing numerical data.\n    - At a high level *numerical computing*\n        - NumPy\n        - R\n        - Julia\n        - Stata\n        - SAS\n\n## Why?\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n- Imagine thinking in digits.\n- To store a ~3 digit number, need $3 \\times 10 = 30$ \"things\" that can hold a number.\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{dot}\n//| echo: false\n//| fig-width: 400px\ndigraph finite_automata {\n  rankdir=TD; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  struct [label=\"{ {<0> 10^0  | <1> 10^1| <2> 10^2}} \"];\n  struct0 [label=\"{0|1|2|3|4|5|6|7|8|9}\"];\n  struct1 [label=\"{0|1|2|3|4|5|6|7|8|9}\"];\n  struct2 [label=\"{0|1|2|3|4|5|6|7|8|9}\"];\n  struct:0 -> struct0\n  struct:1 -> struct1\n  struct:2 -> struct2\n\n}\n```\n\n\n:::\n\n::::\n\n## Binary\n\n- We are familiar with binary encoding.\n- We note: $\\log_2(999) \\lt 10$\n- *Decimal encoding **squanders** $\\dfrac{2}{3}$ of it's storage space.*\n- So we store in binary.\n\n\n\n```{dot}\n//| echo: false\n//| fig-width: 800px\n//| fig-height: 200px\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n\n  struct [label=\"{2^0|2^1|2^2|2^3|2^4|2^5|2^6|2^7|2^8|2^9}|{0|0|0|0|0|0|0|0|0|0}|{1|1|1|1|1|1|1|1|1|1}\"];\n}\n```\n\n\n## Binary\n\n- The benefit here is that is sufficient to note the presence or absence of a digit (`1`) \n- Versus the specific digit $\\in [1,9]$ and presence of absense (`0`)\n\n\n```{dot}\n//| echo: false\n//| fig-width: 800px\n//| fig-height: 200px\ndigraph finite_automata {\n  rankdir=LR; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n\n  struct [label=\"{2^0|2^1|2^2|2^3|2^4|2^5|2^6|2^7|2^8|2^9}|{|1|||1|1|||1|}\"];\n}\n```\n\n\n## Wait a minute.\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n- Why is the ones digit ($n^0$) leftmost ?\n    - The \"least significant bit\" or \"lsb\"\n- In e.g. English place the \"lsb\" last.\n    - CS 276 &rArr;\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n\n```{dot}\n//| echo: false\n//| fig-width: 400px\n//| fig-height: 400px\ndigraph finite_automata {\n  rankdir=TD; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n  edge [color = \"#ffffff\",fontcolor = \"#ffffff\"]\n\n  struct [label=\"{ {<0> 10^0  | <1> 10^1| <2> 10^2}} \"];\n  struct0 [label=\"{||||||6|||}\"];\n  struct1 [label=\"{|||||||7||}\"];\n  struct2 [label=\"{||2|||||||}\"];\n  struct:0 -> struct0\n  struct:1 -> struct1\n  struct:2 -> struct2\n}\n```\n\n\n:::\n\n::::\n\n## Languages\n\n- In e.g. spoken word, makes sense to lead with the biggest value.\n    - 200 of something is closer to 299 of something than 0 of something is to 9 of something.\n- In e.g. programming, we often lead with lowest numerical index.\n    - We look at the `arr[0]` or something before the `arr[1]` of something.\n\n## In Practice\n\n- We end up with\n```{.python}\n\"276\"[0] == '2' and 276 % (10 ** 1) == 6\n```\n- Confusing!  \n\n## Annoyance\n\n- This gets *very annoy* when trying to move numbers around that don't quite fit in some number of bits.\n    - Say I have 123,456 followers on InstagramðŸ“·\n    - Boycott Meta etc etc.\n    - And/or follow me [@calvinallegedly](https://www.instagram.com/calvinallegedly/)\n- Also imagine it is 1969 and you only have 8 bit integers.\n\n## Scanf\n\n- We can use `scanf` - the inverse of `printf`\n    - We give `scanf` a format string, like:\n        -   `%d,%d`\n        -   Two comma-separated decimal values.\n        -   Astute observers will realize where .csv's come from\n            - From whence .csv's hail\n\n\n```{.C}\nscanf(\"%d,%d\");\n```\n\n## Test\n\n- Test it\n\n```{.C filename=\"scanf.c\"}\n#include <stdio.h>\n\nint main() {\n    scanf(\"%d,%d\");\n    return 0;\n}\n```\n\n## Warning\n\n- We draw a warning for missing *arguments* for each *format code*\n\n```{.email}\nscanf.c: In function â€˜mainâ€™:\nscanf.c:4:13: warning: format â€˜%dâ€™ expects a matching â€˜int *â€™ argument [-Wformat=]\n    4 |     scanf(\"%d,%d\");\n      |            ~^\n      |             |\n      |             int *\nscanf.c:4:16: warning: format â€˜%dâ€™ expects a matching â€˜int *â€™ argument [-Wformat=]\n    4 |     scanf(\"%d,%d\");\n      |               ~^\n      |                |\n      |                int *\n```\n\n## Arguments\n\n- We need integers.\n\n```{.C}\n    int a,b;\n```\n\n- Well actually, were asked to provided an `int *` for each integer format code.\n\n> format â€˜%dâ€™ expects a matching â€˜int *â€™ \n\n```{.C}\n    int a[1], b[1]; /* Think of these as arrays of one element. */\n```\n\n- Regard `int *n` is just an `int n[m]` for which we don't say what `m` is. \n\n## []\n\n:::: {.columns}\n\n::: {.column width=\"70%\"}\n\n- Some of you used arrays of unspecified length on `enigma`, that is banned by `c89`.\n- You should know how long the arrays in your code are.\n- This is a security class and that stuff matters.\n- [See more](https://xkcd.com/1354/)\n- [Reade more](https://heartbleed.com/)\n\n:::\n\n::: {.column width=\"30%\"}\n\n![](https://imgs.xkcd.com/comics/heartbleed_explanation.png)\n\n:::\n\n::::\n\n## Use small arrays\n\n- Just like the Python `x = [0]` example.\n\n```{.C filename=\"scanf.c\"}\n#include <stdio.h>\n\nint main() {\n    int a[1], b[1];\n    scanf(\"%d,%d\", a, b);\n    return 0;\n}\n```\n\n- Use as follows:\n```{.email}\n$ gcc scanf.c && ./a.out\n123,456\n$\n```\n- Clean exit!\n\n## Use small arrays\n\n- Print the value commaless.\n\n```{.C filename=\"scanf.c\"}\n#include <stdio.h>\n\nint main() {\n    int a[1], b[1];\n    scanf(\"%d,%d\", a, b);\n    return 0;\n}\n```\n\n- Use as follows:\n```{.email}\n$ gcc scanf.c && ./a.out\n123,456\n$\n```\n- Clean exit!\n\n## Printing\n\n- Let's print our values back...\n\n```{.C filename=\"scanf.c\"}\n#include <stdio.h>\n\nint main() {\n    int a[1], b[1];\n    scanf(\"%d,%d\", a, b);\n    printf(\"%d%d\\n\", a, b);\n    return 0;\n}\n```\n- Oops!\n\n```{.email}\nscanf.c: In function â€˜mainâ€™:\nscanf.c:6:14: warning: format â€˜%dâ€™ expects argument of type â€˜intâ€™, but argument 2 has type â€˜int *â€™ [-Wformat=]\n    6 |     printf(\"%d%d\\n\", a, b);\n      |             ~^       ~\n      |              |       |\n      |              int     int *\n      |             %ls\n...\n```\n\n## Printing\n\n- Print needs values, not references.\n\n```{.C filename=\"scanf.c\"}\n#include <stdio.h>\n\nint main() {\n    int a[1], b[1];\n    scanf(\"%d,%d\", a, b);\n    printf(\"%d%d\\n\", a[0], b[0]);\n    return 0;\n}\n```\n- Nothing too fancy.\n\n```{.email}\n$ gcc scanf.c && ./a.out\n123,456\n123456\n$\n```\n\n## Double it \n\n- Let's say we want to double our input value.\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```{.C filename=\"scanf.c\"}\n#include <stdio.h>\n\nint main() {\n    int a[1], b[1];\n    scanf(\"%d,%d\", a, b);\n    a[0] *= 2;\n    b[0] *= 2;\n    printf(\"%d%d\\n\", a[0], b[0]);\n    return 0;\n}\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n```{.email}\n$ gcc scanf.c && ./a.out\n123,456\n246912\n$ ./a.out\n123,567\n2461134\n$\n```\n\n- Uh oh.\n\n:::\n\n::::\n\n## Carries\n\n- One reason to put the one's place first is for carries.\n\n\n```{dot}\n//| echo: false\n//| fig-width: 800px\n//| fig-height: 200px\ndigraph finite_automata {\n  rankdir=TD; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n\n  struct [label=\"{2^||+|=}|{0|1|0|1}|{1|0|1|1}|{2|0|0|0}|{3|1|1|?}\"];\n}\n```\n\n- As we add across a value, we want to carry over a bit to a higher power.\n- Same with multiply!\n\n## Carries\n\n- One reason to put the one's place first is for carries.\n\n\n```{dot}\n//| echo: false\n//| fig-width: 800px\n//| fig-height: 200px\ndigraph finite_automata {\n  rankdir=TD; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n\n  struct [label=\"{2^||+|c|=}|{0|1|0|0|1}|{1|0|1|0|1}|{2|0|0|0|0}|{3|1|1|0|0}\"];\n}\n```\n\n\n## Carries\n\n- Addition is easier least-to-most\n\n\n```{dot}\n//| echo: false\n//| fig-width: 800px\n//| fig-height: 200px\ndigraph finite_automata {\n  rankdir=TD; bgcolor=\"#191919\";\n  node [fontcolor = \"#ffffff\", color = \"#ffffff\", shape=record];\n\n  struct [label=\"{2^||+|c|=}|{0|1|0|0|1}|{1|0|1|0|1}|{2|0|0|0|0}|{3|1|1|0|0}|{4|0|0|1|1}\"];\n}\n```\n\n- This denotes a binary add of `0b01001` to `0b01010` which equals `0b10011`\n```{.python}\n>>> bin(0b01001 + 0b01010)\n'0b10011'\n>>> bin(0b01001 + 0b01010)[2::-1]\n'1b0'\n>>> bin(0b01001 + 0b01010)[:2:-1]\n'1100'\n>>> bin(0b01001 + 0b01010)[:1:-1]\n'11001'\n```\n\n## Does it matter?\n\n- Kinda.\n- This is called, Endianness, the subject a latter lab.\n- It mostly matters when we rearrange numbers around.\n    - SHA256 works with chunks of various sizes - 8, 32, 256, 512.\n    - In which order do we place values from 4 8-bit fields into 1 32-bit field.\n\n# Casts\n\n## 32 -> 64\n\n- It is common to find 32 bit code that is running on 64 bit devices.\n    - Say e.g. \"World of Warcraft: Classic\"\n        - Released in 2004 for 32 bit devices.\n        - Repopularized in 2019 then 2024\n        - Literal trillion dollar company (MS)\n- Need a *very good* way to go between 32 and 64 bits.\n\n## Casts\n\n- That way is *casts*\n- In C, we prefix a value by a type (in parens) when assigning it to a variable.\n    - `1` is a value.\n    - `long` is a type (usually the 64 bit type)\n    - `(long)1` is the value of `1` as a 64 bit type\n```{.C}\nlong x = 0;\nint y = 10;\nx = (long)y;\n```\n\n## Arrays\n\n- We regarded, following \"macros\", C integers as akin to arrays of booleans.\n- C integers can also be regarded as arrays of bytes.\n- For example, an `int` is commonly 4 bytes, or `char` values.\n- We can achieve this with a cast.\n\n## Example\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n```{C, eval=FALSE, `code-line-numbers`=\"2\"}\n#include <stdio.h>\n\nint main() {\n    int *x;\n    char buf[4];\n    buf[0] = 0xA;\n    buf[1] = 0xB;\n    buf[2] = 0xC;\n    buf[3] = 0xD;\n    x = (int *)buf;\n    printf(\"%x\\n\", x[0]);\n    return 0;\n}\n```\n\n\n:::\n\n::::\n\n",
    "supporting": [
      "encode_files"
    ],
    "filters": [],
    "includes": {}
  }
}