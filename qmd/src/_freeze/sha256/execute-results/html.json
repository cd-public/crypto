{
  "hash": "8155156e79fc8ea9d43e8d0318a2b6d5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: SHA256\nauthor: Prof. Calvin\nsubtitle: \"Week 0x3\"\ninstitute: Crypto\nformat: \n    revealjs: \n        code-fold: false\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n\nexecute:\n    echo: true\n    cache: true\n    freeze: true  ## never re-render during project render\n---\n\n\n## Announcements\n\n- **Welcome** to variously CS 276/CS 540\n- **Action Items**:\n  - How was Macros?\n  - Next homework coming out now - SHAinC\n\n## Today\n\n- SHA256\n    -   Why?\n    -   What?\n    -   How?\n\n## Slide Credit\n\n-   [**Saravanan Vijayakumaran**](https://www.ee.iitb.ac.in/~sarva/)\n-   sarva@ee.iitb.ac.in  \n-   Department of Electrical Engineering  \n-   Indian Institute of Technology Bombay  \n\n# Why?\n\n## Hash Functions\n\n-   Methods for **deterministically** compress a long input string to a shorter output called a digest\n    -   Also called \"signature\"\n    -   Can hash *anything stored in computer*\n-   These are also called \"compression\" or \"one-way\" hash functions.\n\n## Hash Merits\n\n-   Primary requirement is that it should be infeasible to find collisions, \n    -   i.e. no two inputs have same digest.\n    -   If I download Ubuntu and check the signature, I should know it's Ubuntu.\n    -   If Ubuntu and a malware package have the same signature, useless.\n\n## Non-Cryptographic\n\n-   Used to build **<strong>**hash tables**</strong>** \n    -   Key-value stores with $\\mathcal{O}(1)$ lookup time. \n    -   [My hashtable/hashmap slides](https://cd-public.github.io/slide_portable/hashmap.html#/title-slide)\n-   Example: Python `hash`\n\n::: {#93898c7f .cell execution_count=1}\n``` {.python .cell-code}\nprint(\"\\n\".join([f\"{hash(a):+d}\" for a in \"ABCDE\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+307432586377922195\n+8720052512513840967\n+7066593843844395842\n-6025104745690603236\n-9067290596465053571\n```\n:::\n:::\n\n\n## Example.tex\n\n-   Let $M$ be the size of some hash table\n-   Take $a \\in \\mathbb{N} : a < M \\land \\gcd(a, M) = 1$\n    -   That is, two positive coprime integers.\n-   Any integer value $x$ can be mapped into $\\mathbb{N}/(M) = \\{0,1,\\ldots, M-1\\}$\n    \n```LaTeX\nh_a(x) = a x \\pmod{M}\n```\n$$\nh_a(x) = a x \\pmod{M}\n$$\n\n## Example.py\n-   We can express in a programming language.\n-   We note that 257 == 0x101 is prime.\n    -   And therefore $\\forall M : \\gcd(257,M) = 1$\n\n::: {#42c862e8 .cell execution_count=2}\n``` {.python .cell-code}\nimport math\nh = lambda x, a, M : (a * x) % M\na, M = 0x05, 1 << 0x08\nassert(all((not math.gcd(a, M) == 1) or h(x, a, M) in range(M) for x in range(M)))\nprint('h'+str((0xDA7A,a,M)), '=', h(0xDA7A,a,M))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh(55930, 5, 256) = 98\n```\n:::\n:::\n\n\n## Example.c\n-   We note a high performance special case.\n-   Let $w$ be the bit size used to store numbers\n    -   Likely 32 == 0x20 for C `unsigned`\n    -   $W$ stands for [word](https://en.wikipedia.org/wiki/Word_(computer_architecture)) size\n-   Take $W = 2^w$ and $M = 2^m$\n\n```{.C}\nunsigned int h(unsigned int x, unsigned int a, unsigned int m) {\n    return (a * x) >> (sizeof(unsigned int) * 0x10 - m); \n}\n```\n\n## Collisions\n\n-   A **collision** occurs if\n$$\n\\exists x, x' : x \\neq x' \\land h(x) = h(x')\n$$\n-   That is, this assertion *fails*:\n```{.py}\nx_0, x_1 = 1,2\nassert(((x_0 != x_1) and (h(x_0, a, M) == h(x_1, a, M))))\n```\n-   **Goal:** minimize:non-crypto::avoid:crypto collisions.\n    -   Achieve this via a large codomain for $h$\n\n## Codomain:\n\n> [\"In mathematics, a codomain or set of destination of a function is a set into which all of the output of the function is constrained to fall. It is the set $Y$ in the notation $f: X â†’ Y$. The term range is sometimes ambiguously used to refer to either the codomain or the image of a function.\"](https://en.wikipedia.org/wiki/Codomain)\n\n## Test it:\n\n::: {#64cdda2b .cell execution_count=3}\n``` {.python .cell-code}\nh = lambda x, a, M : (a * x) % M\na, M = 0x05, 1 << 0x08\nassert(set(h(x, a, M) for x in range(M)) == set(range(M)))\n```\n:::\n\n\n-   As a rule we shouldn't try to write proofs/definitions in Python, but...\n-   Small $M = 2^{0x08} = 256$ means our computer can handle all possibilities.\n\n## Visualize:\n\n<img style=\"filter: invert(100%);\" src=\"https://www.ee.iitb.ac.in/~sarva/courses/EE720/2023/slides/images/codomain-256.svg\">\n\n# What?\n\n## Cryptographic\n\n-   Begin with SHA-2 (Secure Hash Algorithm 2).\n    -   A family of cryptographic hash functions.\n    -   By the [U.S. National Security Agency (NSA)](https://www.youtube.com/watch?v=mJHvSp9AKYg)\n-   Published by the U.S. National Institute of Standards and Technology (NIST) in 2001.\n\n## Context\n-   SHA-1, released in 1995, found to have significant vulnerabilities.\n-   Growing concerns about the security of SHA-1 led to the development of SHA-2.\n    -   SHA-3 released in 2015, not in wide use.\n    -   For *if* weakness in SHA-2 discovered.\n    -   SHA-2 regarded as secure in 2025.\n\n## Family\n- Six hash functions release August 2001:\n  - SHA-224\n  - SHA-256\n  - SHA-384\n  - SHA-512\n  - SHA-512/224\n  - SHA-512/256\n\n## Adoption and Usage\n-   SHA-2 has been widely adopted in \n    -   Digital signatures\n    -   Certificate validation\n    -   File integrity verification.\n    -   **Blockchain:** \n        -   1 of ~2 core technologies of Bitcoin\n        -   SHA-256 specifically\n\n## SHA-2 Pledge\n\n-   I need a verbal confirmation:\n    -   Even though we will implement cryptography...\n    -   We assume their insecurity as we learn to:\n        -   Test our code\n        -   Write proofs\n        -   Use compilers\n    -   We don't know what side channel attacks are.\n        -   I say: out-of-scope.\n\n## SHA-256 Overview\n\n- **SHA-2** with a **256-bit output length**\n- Accepts bit strings of length up to $2^{64} - 1$\n    -   ~20 quintillion bits\n    -   ~17 million terabytes\n\n# How?\n\n## Two Stages\n\n- Output calculation has two stages:\n  1. **Preprocessing**\n  2. **Hash Computation**\n\n## Preprocessing\n\n- A 256-bit state variable $H^{(0)}$ is initialized:\n\n\\begin{align*}\n\\begin{split}\n   H_0^{(0)} = \\texttt{0x6A09E667}, \\quad H_1^{(0)} = \\texttt{0xBB67AE85},\\\\\n   H_2^{(0)} = \\texttt{0x3C6EF372}, \\quad H_3^{(0)} = \\texttt{0xA54FF53A},\\\\\n   H_4^{(0)} = \\texttt{0x510E527F}, \\quad H_5^{(0)} = \\texttt{0x9B05688C},\\\\\n   H_6^{(0)} = \\texttt{0x1F83D9AB}, \\quad H_7^{(0)} = \\texttt{0x5BE0CD19}.\n\\end{split}\n   \\end{align*}\n\n- \"Fractional parts of square roots of first primes\"\n\n## Input Padding\n\n- The input $M$ is padded to a length that is a multiple of 512.\n\n- Let $M$ be $l$-bits long.\n- Find the smallest non-negative $k$ such that:\n$$\nk + l + 65 \\equiv 0 \\pmod{512}\n$$\n\n## Padding Content\n\n- Append $k + 65$ bits to $M$: \n    -   A single one (`1`), followed by \n    -   $k$ zeros (`0`), followed by\n    -   The 64-bit representation of $l$.\n$$\n\\begin{align*}\n1\\underbrace{000 \\cdots 000}_{k \\textrm{ zeros}}\\underbrace{l}_{\\textrm{ 64 bits}} \\\\\n\\end{align*}\n$$\n\n## Example.py\n\n-   We can solve numerically in Python, but...\n-   Perhaps easier to show with strings.\n\n::: {#40b4906e .cell execution_count=4}\n``` {.python .cell-code}\nM = \"Hello there I am a message.  \" * 15\nl = len(M.encode('utf-8')) * 8\nk = 512 - (l + 65) % 512\n\"l=\", l, \"k=\", k, \"pad=\", \"0x1\" + \"0\" * (k//4) + f\"{l:016x}\" ## 64 // 4 == 16\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n('l=', 3480, 'k=', 39, 'pad=', '0x10000000000000000000000d98')\n```\n:::\n:::\n\n\n-   The arithmetic form is left an exercise for the interested student.\n    -   My solution was 10-20 characters of code.\n\n## Hash Computation\n\n- Padded input is split into $N$ 512-bit blocks:\n    - We note this is 1-indexed, by convention.\n$$\nM^{(1)}, M^{(2)}, \\ldots, M^{(N)}\n$$\n- When testing, expect to have only $M^{(1)}$\n    - 512 is a lot of bytes to e.g. type in.\n    - Test more once it works.\n\n## Hash Type\n- The hash function has the following type:\n$$\nf: M:\\{0,1\\}^{512} \\times H:\\{0,1\\}^{256} \\rightarrow H':\\{0,1\\}^{256}\n$$\n- Given $H^{(i-1)}$, calculate $H^{(i)}$ using:\n $$\n H^{(i)} = f(M^{(i)}, H^{(i-1)}), \\quad 1 \\leq i \\leq N.\n $$\n    - 1-indexed\n\n\n## Words\n\n-   We specify bitwise operations over **exactly** 32 bit words.\n-   The industry standard is to use `stdint`\n```{.C}\n#include <stdint.h>\n\n/* uint32_t is \"unsigned integer of size 32 type\" */\nuint32_t rotate(uint32_t a, uint32_t b) {\n    asm(\"rorl %%cl, %0\" : \"+r\" (a) : \"c\" (b));\n    return a;\n}\n```\n\n## Operations\n\n- Bitwise logical operations\n    -   Unary,\n    -   Binary, and\n    -   Ternary, and\n- Shift/rotate operations\n    -   Simple, and\n    -   Composite\n\n## Words\n\n- Bitwise logical operations accept 1, 2, or 3 words of size 32 (`uint32_t`) and produce one word.\n    -   Term these words $U$, $V$, $W$\n- Shift/rotate operations additionally accept one natural number $n$ < 32.\n    -   Term this $n$\n\n## Unary Bitwise\n\n- There is only one: \n- 'bitwise complement'/'bitwise logical not':\n$$\n\\lnot U\n$$\n- Expressible with `uint32_t` in C:\n```{.C}\n/* 32 bit bitwise complement, exact */\nuint32_t complement(uint32_t u) {\n    return ~u;\n}\n```\n\n## Binary Bitwise\n\n- $U \\land V$, $U \\lor V$, $U \\oplus V$: AND, OR, XOR\n- As from printb/macros.\n```{.C}\nuint32_t and(uint32_t u, uint32_t v) { /* bitwise and */\n    return u & v;\n}\n\nuint32_t ior(uint32_t u, uint32_t v) { /* inclusive or */\n    return u | v;\n}\n\nuint32_t xor(uint32_t u, uint32_t v) { /* exclusive or */\n    return u ^ v;\n}\n```\n\n## Addition\n\n- C addition is a binary bitwise operation:\n- Equivalent to integer sum module $2^{32}$\n\n::: {#c007e394 .cell execution_count=5}\n``` {.python .cell-code}\nfrom ctypes import c_uint ## this won't work in pypy\ndef addition(u:c_uint, v:c_uint) -> c_uint:\n    return c_uint(u + v)\n\naddition(4000000000, 4000000000) , addition(4, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n(c_ulong(3705032704), c_ulong(8))\n```\n:::\n:::\n\n\n- For me, Python coerces `c_uint` to `c_ulong`.\n    - Good reason to use C\n\n## C Math\n- C addition on `uint32_t` is already modulo $2^{32}$\n    - What else would it be?\n    - Finite number of bits means finite values.\n\n```{.C filename=\"bitops.c\"}\n#include <stdio.h>\n#include <stdint.h>\n\nint main() {\n    uint32_t u = 4000000000;\n    printf(\"%u + %u = %u\\n\", u, u, u+u);\n    u = 4;\n    printf(\"%u + %u = %u\\n\", u, u, u+u);\n    return 0;\n}\n```\n\n## C Math\n- We get the same values as the Python `c_uint`\n- Python is written in C:\n\n```{.email filename=\"/bin/sh\"}\n$ gcc bitops.c --std=c89 -Wall -Wextra -Werror -Wpedantic -O2 -o bitops\n$ ./bitops\n4000000000 + 4000000000 = 3705032704\n4 + 4 = 8\n$ \n```\n\n## Ternary Bitwise\n\n- `CHOICE` and `MEDIAN`, expressed logically:\n$$\n\\text{CHOICE}(U, V, W) = (U \\land V) \\oplus (\\lnot U \\land W)\n$$\n$$\n\\text{MEDIAN}(U, V, W) = (U \\land V) \\oplus (U \\land W) \\oplus (V \\land W)\n$$\n- There exist numerous formulations of median.\n    - This one lifted from [GitHub user B-Con](https://github.com/B-Con/crypto-algorithms)\n\n## Shifts/Rotates\n\n- Compared to bitwise, they:\n    - Still work on a 32 bit word, but\n    - Also work on a value $n : 0 \\leq n \\leq 31$\n    - Or,\n    ```py\n    assert(n in range(32))\n    ```\n\n## Simple Shift/Rotate\n\n- Bitwise shift right `>>` / x86 `shrl`\n$$\n\\textsf{SHR}^n(U) = \\underbrace{000 \\cdots 000}_{n \\textrm{ zeros}} u_0 u_1 \\cdots u_{30-n} u_{31-n}\n$$\n- The `ROTATE` macro / x86 `rorl`\n$$\n\\textsf{ROTR}^n(U) =  \\underbrace{u_{32-n} u_{33-n} \\cdots u_{30} u_{31}}_{n \\textrm{ bits}} u_0 u_1 \\cdots u_{30-n} u_{31-n}\n$$\n\n## Composites\n\n- While not required...\n- ...easier to understand SHA256 with composites:\n$$\n\\begin{align*}\n\\Sigma_0(U)&= \\textsf{ROTR}^{02}(U) \\oplus \\textsf{ROTR}^{13}(U) \\oplus \\textsf{ROTR}^{22}(U) \\\\\n\\Sigma_1(U)&= \\textsf{ROTR}^{06}(U) \\oplus \\textsf{ROTR}^{11}(U) \\oplus \\textsf{ROTR}^{25}(U) \\\\\n\\sigma_0(U)&= \\textsf{ROTR}^{07}(U) \\oplus \\textsf{ROTR}^{18}(U) \\oplus \\textsf{SHR}^{03}(U) \\\\\n\\sigma_1(U)&= \\textsf{ROTR}^{17}(U) \\oplus \\textsf{ROTR}^{19}(U) \\oplus \\textsf{SHR}^{10}(U)\n\\end{align*}\n$$\n- Macros and helper functions both work well here.\n\n## Hash Computation\n\n- 4 steps for each 512 bit chunk.\n- First chunk, also use pre-computed $H$ values.\n    - Called, say \"initial hash values\"\n    - Successive chunks use previous chunk's hash\n- All chunks share pre-computed $K$ values.\n    - Called, say \"round contants\"\n    - \"Fractional parts of cube roots of first primes\"\n\n## Parts\n\n0. Preprocess\n1. Set Message Schedule Array\n    -   64 word array\n2. Set Working Variables\n    -   8 word sized variables\n3. Main Loop\n    -   Word level operations\n4. Update hash value\n\n## 1. Set Message Schedule Array\n- $M^{(i)}_j$ is the $j$-th 0-indexed 32 bit word of the $i$-th 1-indexed 512 bit chunk of message $M$\n    - A word is 4 letters\n    - A chunk is short tweet (64 chars)\n    - $M$ can be, e.g., Linux, the *Iliad*\n\n$$\nW_j = \n\\begin{cases} \nM^{(i)}_j & 0 \\leq j \\leq 15 \\\\\n\\sigma_1(W_{j-2}) + W_{j-7} + \\sigma_0(W_{j-15}) + W_{j-16} & 16 \\leq j \\leq 63\n\\end{cases}\n$$\n\n\n\n## 2. Set Working Variables\n\n- Initialize eight 32-bit words based on the prior hash.\n $$\n (A, B, C, D, E, F, G, H) = (H^{(i-1)}_0, \\ldots, H^{(i-1)}_7).\n $$\n\n## 3. Main Loop\n\n- Iterate $j = 0$ to $63$:\n```py\nfor j in range(64):\n```\n- Precompute two temporary values (or not)\n$$\n\\begin{align}\n\\begin{split}\n& T_1  = H + \\Sigma_1(E) + \\textsf{CHOICE}(E,F,G) + K_j + W_j \\\\\n& T_2  = \\Sigma_0(A) + \\textsf{MEDIAN}(A,B,C) \\\\\n\\end{split}\n\\end{align}\n$$\n- Update the working variables\n$$\n(A,B,C,D,E,F,G,H)  = (T_1+T_2, A, B, C, D+T_1, E, F, G)\n$$\n\n## 4. Update hash value\n\n- Conclude the work on $M^{(i)}$ by finding $H^{(i)}$\n\n$$\nH^{(i)}_j = A + H^{(i-1)}_j, \\quad j = 0, \\ldots, 7\n$$\n\n# Resources\n\n- [Wikipedia Pseudocode](https://en.wikipedia.org/wiki/SHA-2#Pseudocode)\n    - I used this to implement.\n- [Saravanan Vijayakumaran's Slides](https://www.ee.iitb.ac.in/~sarva/courses/EE720/2023/slides/hash-functions.html#/sha-256)\n    - I used this to typeset the slides.\n- [@manceraio's .js demo](https://sha256algorithm.com/)\n    - Inspired my text-only Enigma.\n\n",
    "supporting": [
      "sha256_files"
    ],
    "filters": [],
    "includes": {}
  }
}