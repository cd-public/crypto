{
  "hash": "08b4f4c04d94c70e4a21dd5aaa20d81c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Euclid\ntheme: dark\nauthor: Prof. Calvin\nsubtitle: \"Week 0x7\"\ninstitute: Crypto\nformat: \n    revealjs: \n        code-fold: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n\nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n    code-fold: false\n---\n\n\n# Announcements\n\n- **Welcome** to variously CS 276/CS 540\n  - We introduce an algorithm that makes key generation viable.\n- **Action Items**:\n  - RSAinC due this week\n  - BigRSA due 31 Mar\n  - Midterm next week\n  \n# Today\n- Euclidean division\n- Euclidean algorithm\n- Extended Euclidean algorithm\n- Bézout's identity\n\n# Review\n\n# 3. $\\lambda(n)$\n\n- This one is kept secret by the way.\n- It so happens:\n$$\n\\forall p,q \\in \\mathbb{P} : \\lambda(pq) = \\text{lcm}(p-1, q-1)\n$$\n- There's fast ways to this, but anything goes this week.\n\n# LCM\n\n- Least common multiple\n\n```{.python}\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor of a and b.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Calculate the Least Common Multiple of a and b.\"\"\"\n    return a * b // gcd(a, b)\n```\n\n# MMI\n\n- Multiplicative Modular Inverse\n\n```{.python}\ndef find_d():\n  d = 1\n  while 1 != (d * e % hide_λ()):\n    d += 1\n  return d\n```\n\n# ModExp\n\n- Exponentation modulo $n$.\n\n```{.python}\ndef modexp(m, e, n):\n  if e == 0:\n      return 1\n  if e == 1:\n      return m % n\n  if e % 2:\n      return (m * modexp(m*m % n, e//2, n)) % n\n  return  modexp(m*m % n, e//2, n) % n\n```\n\n# Context\n- Each of these operations are dealing with, fundamentally, the same problem.\n- We have big numbers we want to work with but,\n- None are bigger than $n$, and\n- The bigger the number, the harder the work.\n\n# Euclidean Division\n\n- Division as implemented by \"bigdiv\":\n\n```{.C}\nuint64_t bigdiv(uint64_t *num, uint64_t *den, uint64_t *quo, uint64_t *rem) {\n    return 0;\n}\n\nuint64_t bigquo(uint64_t *num, uint64_t *den, uint64_t *quo) {\n    uint64_t rem[S];\n    bigdiv(num,den,quo,rem);\n    return 0;\n}\n\nuint64_t bigrem(uint64_t *num, uint64_t *den, uint64_t *rem) {\n    uint64_t quo[S];\n    bigdiv(num,den,quo,rem);\n    return 0;\n}\n```\n\n# Naive Division\n\n- Entry-level categorization, term it \"naive\"\n    - often over $\\mathbb{Q}$ or $\\mathbb{R}$\n    - `quotient:float = division(dividided:int|float,divisor:int|float)`\n    - In Python $\\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Q}$\n    - Python `/` for all values, C `/` for float types.\n    \n# Integer Division\n\n- Integer division - often over $\\mathbb{N}$ or $\\mathbb{Z}$\n    - `quotient:int = division(dividided:int,divisor:int)`\n    - Python `//` for int types, C `/` for int types.\n    \n# We note\n\n- Many sets of numbers are not closed under division\n    - $\\exists x,y \\in \\mathbb{N} : x/y \\not\\in \\mathbb{N}$\n- These sets are closed under integer division but then lack multiplicative inverses.\n    - $\\exists n \\in \\mathbb{N} : \\nexists m \\in \\mathbb{N} : n \\times m \\in \\mathbb{N}$\n- These are all bad!\n\n# Euclidean Division\n\n- Euclidean division solves this problem by *changing the type of the function*\n    - **NOT** by changing the types of the operands (inputs, divisor, divisend, numerator, denominator)\n    - **YES** by changing the *number of return values*\n- We will simply have two return values.\n    - We recall this impossible in C (loud cheers)\n    \n# Euclidean Division\n\n- Also called \"division with remainder\".\n    - Generally regarded as being applied to the integers, and works well for unsigned ints.\n    - Often termed `div`, `/`, `\\`, and `%`, I used div for \"bigdiv\" since the others were taken.\n- Named as a result of \"Euclidean Algorithm\", which is used in cryptography!\n\n# Euclidean Division\n\n- In Python:\n\n```{.python}\ndef div(x:int, y:int) -> tuple[int, int]:\n    # Euclidean Division\n    return x // y, x % y\n```\n\n- In Latex: $\\mathbb{Z} \\times \\mathbb{Z} \\rightarrow \\mathbb{Z} \\times \\mathbb{N}$\n\n# Terminology\n\n- Dividend / Divisor = Quotient\n- Dividend % Divisor = Remainder\n- Dividend ~= Numerator\n- Divisor ~= Denominator\n- Quotient ~= Fraction ~= Ratio\n- Remainder is modulo if dividend and divisor are naturals.\n\n# Equality\n\n- Divisor $\\times$ Quotient + Remainder = Dividend\n\n# Constraints\n\n- The remainder is restricted to the naturals, even for division over the integers.\n- The remainder is restricted to be smaller than divisor - the thing by which we divide.\n\n# Constraints\n\n- The quotient is the number of largest number absolute by which the divisor may be multipled such the product is absolutely less than the divisend.\n- The remainder is the smallest positive value such that the sum of the remainder and the product of the quotient and divisor is equal to the divisend.\n\n# Takeaways\n\n- Remainders are small and positive (good).\n- We get to keep using integers, and through some effort can stick to naturals.\n- This is good if we want to work with unsigned integers.\n\n# Today\n- &check; Euclidean division\n- Euclidean algorithm\n- Extended Euclidean algorithm\n- Bézout's identity\n\n# Sidebar\n\n- The Euclidean algorith is:\n    - An algorithm with,\n    - Algorithm in the name\n- We love to see it.\n- Also called \"Euclid's Algorithm\"\n    - Greek scholar preserved by Islamic scholars\n    - Thank you محمد بن موسى خوارزمی\n\n# Goals\n\n- Given two values, the Euclidean algorithm finds the greatest common denominator.\n- Generally, it proceeds either iteratively or recursively.\n    - It is an algorithm, not an implementation.\n- Historically used to synthesize integer division from integer subtraction, now primary use in cryptography.\n\n\n# Example\n\n- Suppose we have\n```{.python}\na, b = 1071, 462\n```\n- We wish to find their *greatest common denominator*\n\n# Initialize\n\n1. Take the larger value\n```{.python}\nx, y = max(a,b), min(a,b)\n```\n\n\n# Substract \n\n2. Subtract the smaller value from the larger value until it is no longer larger.\n```{.python}\nwhile x >= y:\n    x -= y\n```\n\n# Loop\n\n3. Repeat...\n\n```{.python}\nx, y = max(x,y), min(x,y)\n```\n\n# Terminate\n\n4. Stop when either x or y is zero\n\n```{.python}\nx, y = x != 0 and y != 0 ? max(x,y), min(x,y) : exit()\n```\n\n# Iteratively\n\n```{.python}\n# i am not about to try to spell \"uelcidan lagorhtim\"\ndef ea(a:int, b:int) -> int: \n    while min(a,b) != 0:\n        a, b = max(a,b), min(a,b)\n        while a >= b:\n            a -= b\n    return max(a,b)\n```\n\n# Modulo\n\n- Essential we calculate a modulo or remainder (depending)\n- Then... do that again.\n    \n```{.python}\n# i am not about to try to spell \"udelcian altoghtn\"\ndef ea(a:int, b:int) -> int: \n    while min(a,b) != 0:\n        a, b = max(a,b), min(a,b)\n        a %= b\n    return max(a,b)\n```\n\n- Recall - this *invented* division and modulo, so it can be done without assuming division and modulo.\n    - We are using it to do `gcd`, and exist in a world with division and modulo.\n    \n# Recursively\n\n- Easier for me to understand recursively, either with mod or without.\n    - Here's one mod implementation.\n\n```{.python}\n# Have to make a lot of design decisions here, this is one variant\nrecmod = lambda a, b: recmod (a - b, b) if a - b >= 0 else a\n```\n\n\n# Recursively\n\n- Easier for me to understand recursively, either with mod or without.\n    - Here's recursive EA\n\n```{.python}\n# Much easier if we assume argument order, of course\nrec_ea = lambda a, b : rec_ea(max(a,b) % min(a,b), min(a,b)) if min(a,b) > 0 else max(a,b)\n\n# I much prefer\nhelper = lambda a, b : helper(b, a % b) if b else a\nrec_ea = lambda a, b : helper(max(a,b), min(a,b))\n```\n\n# With `def`\n\n- We do not all love inlining, and that's okay!\n\n```{.python}\ndef ea(a:int, b:int) -> int:\n    a, b = max(a,b), min(a,b)\n    def inner(a, b):\n        if b:\n            return inner(b, a % b)\n        else: \n            return a\n    return inner(a,b)\n```\n\n# Simplest\n\n- We can remove type hints and just trust bigger first.\n\n```{.python}\ndef ea(a, b):\n    if b:\n        return ea(b, a % b)\n    return a\n```\n\n# Example\n\n- `ea(1071, 462)`\n- I will use the following:\n```{.python}\ndef ea(a, b):\n    print(f\"a = {a:4d}, b = {b:4d}\")\n    if b:\n        return ea(b, a % b)\n    return a\n```\n- We get:\n```{.email}\na = 1071, b =  462\na =  462, b =  147\na =  147, b =   21\na =   21, b =    0\n21\n```\n\n# Test it\n\n- Both are divisible by 21!\n\n```{.python}\n>>> 1071/21\n51.0\n>>> 462/21\n22.0\n```\n\n# Anyways\n\n- This is what GitHub Copilot did, I don't know if we understood it at the time.\n\n```{.python}\ndef gcd(a, b):\n    \"\"\"Calculate the Greatest Common Divisor of a and b.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Calculate the Least Common Multiple of a and b.\"\"\"\n    return a * b // gcd(a, b)\n```\n\n#\n\n::::{.columns}\n\n:::{.column width=\"25%\"}\n\n![](https://upload.wikimedia.org/wikipedia/commons/1/1c/Euclidean_algorithm_1071_462.gif)\n\n:::\n\n:::{.column width=\"75%\"}\n\n> Subtraction-based animation of the Euclidean algorithm. The initial rectangle has dimensions a = 1071 and b = 462. Squares of size 462×462 are placed within it leaving a 462×147 rectangle. This rectangle is tiled with 147×147 squares until a 21×147 rectangle is left, which in turn is tiled with 21×21 squares, leaving no uncovered area. The smallest square size, 21, is the GCD of 1071 and 462.\n\n:::\n\n::::\n\n# Today\n- &check; Euclidean division\n- &check; Euclidean algorithm\n- Extended Euclidean algorithm\n- Bézout's identity\n\n# MMI\n\n- Multiplicative Modular Inverse\n\n```{.python}\ndef find_d():\n  d = 1\n  while 1 != (d * e % hide_λ()):\n    d += 1\n  return d\n```\n\n- This is bad!\n    - This could be a loop over a 4096 bit integer!\n    \n# Slow\n\n- It could loop this many times.\n\n::: {#eaffd156 .cell execution_count=1}\n``` {.python .cell-code .code-overflow-wrap code-fold=\"false\"}\n1 << 4096\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n1044388881413152506691752710716624382579964249047383780384233483283953907971557456848826811934997558340890106714439262837987573438185793607263236087851365277945956976543709998340361590134383718314428070011855946226376318839397712745672334684344586617496807908705803704071284048740118609114467977783598029006686938976881787785946905630190260940599579453432823469303026696443059025015972399867714215541693835559885291486318237914434496734087811872639496475100189041349008417061675093668333850551032972088269550769983616369411933015213796825837188091833656751221318492846368125550225998300412344784862595674492194617023806505913245610825731835380087608622102834270197698202313169017678006675195485079921636419370285375124784014907159135459982790513399611551794271106831134090584272884279791554849782954323534517065223269061394905987693002122963395687782878948440616007412945674919823050571642377154816321380631045902916136926708342856440730447899971901781465763473223850267253059899795996090799469201774624817718449867455659250178329070473119433165550807568221846571746373296884912819520317457002440926616910874148385078411929804522981857338977648103126085903001302413467189726673216491511131602920781738033436090243804708340403154190336\n```\n:::\n:::\n\n\n",
    "supporting": [
      "euclid_files"
    ],
    "filters": [],
    "includes": {}
  }
}