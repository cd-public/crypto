{
  "hash": "8d751f346b7242f5744fcfb3f800b7de",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Logics\ntheme: dark\nauthor: Prof. Calvin\nsubtitle: \"Week 0x8 II\"\ninstitute: Crypto\nformat: \n    revealjs: \n        code-fold: true\n        theme: dark\n        mainfont: monospace\n        slide-number: true\n        show-slide-number: all\n        width: 1050\n        height: 700\n        footer: \"[Home](../index.html)\"\n\nexecute:\n    echo: true\n    cache: true\n    freeze: true  # never re-render during project render\n---\n\n\n# Announcements\n\n- Last Lecture\n    - Security topics unrelated to crypto\n    - Some automata theory\n- Action items\n    - `heap_t` due now\n    - `BTCinC` final is out\n\n\n# Today\n\n- Threat and Threat Models\n- (Trace) Properties\n- Kripke Structures\n- Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n\n# Threat\n\n- \"Security\" is incomplete as a concept.\n\n    *   **What** is secure?\n    *   **For whom** is the 'what' secure?\n    *   **From whom** is the 'what' secure?\n\n# Bitcoin\n\n*   **Bitcoins** are secure.\n*   **For all senders and receivers** the ownership is secured.\n*   **From any third party** the doublespending is secured.\n\n# Limitations\n\n*   Can a third party tell **who** uses the service?\n*   Can a third party tell **when** coins are being sent?\n*   Can a third party tell the **amount** of the transaction?\n\n# Models\n\nUse **threat modeling**:\n\n*   Description of the subject to be modeled\n*   Assumptions that can be checked or challenged\n*   Potential threats to the system\n*   Actions that can be taken to mitigate each threat\n*   A way of validating the model and threats\n\nRead more: [OWASP.org](https://owasp.org/www-community/Threat_Modeling)\n\n\n# \n\n|Informally|Formally|\n|-|-|\n|**What?**|Description of the subject to be modeled|\n|**For whom?**|A way of validating the model and threats|\n|**From whom?**|Potential threats to the system|\n|**Any limitations?**|Assumptions that can be checked|\n|**How?**|Actions that can be taken to mitigate each threat|\n\n# BTC\n\n|Informally|Formally|\n|-|-|\n|**What?**|Currency|\n|**For whom?**|An economy with internet access|\n|**From whom?**|Fraud, central authority, surveillance|\n|**Any limitations?**|Public ledger|\n|**How?**|[bchain.html](bchain.html)|\n\n\n# How?\n\nWe can instead proceed in **four steps**.\n\n1.   **Diagram:** What are we building?\n1.   **Identify threats:** What could go wrong?\n1.   **Mitigate:** What are we doing to defend against threats?\n1.   **Validate:** Have we acted on each of the previous steps?\n\n\n# Diagram\n\n<a style=\"filter:invert(1)\" title=\"Graingert, CC0, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:Bitcoin_Transaction_Visual.svg\"><img width=\"80%\" alt=\"The mine is closed and the key must stop working.  And this key structure has stopped already.  by the reason for moving the blueprint and will use the code to confirm the AI ​​service to verify the person instead  and generate income into the new...\" src=\"https://upload.wikimedia.org/wikipedia/commons/c/ce/Bitcoin_Transaction_Visual.svg\"></a>\n\n# Threats\n\n- What if?\n    - Two entities have the same private key?\n    - Dishonest nodes have more compute power?\n    - Internet goes down?\n\n# Mitigate\n\n- Well...\n    - Keys are ~4096 bit...\n    - There are other more lucrative uses of compute than competing with BTC nodes\n    - If the internet goes down, coins can't be spent but persist locally\n\n# Validate\n\n- This is new!\n- Cryptobook uses \"Attack Games\"\n- We explore \"digital signature\"\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n> We give\nthe adversary the power to mount a **chosen message attack**, namely the attacker can request the\nsignature on any message of his choice. Even with such power, the adversary should not be able\nto create an **existential forgery**, namely the attacker cannot output a valid message-signature\npair $(m, \\omega)$ for some new message $m$. \n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* The challenger runs $(pk, sk) \\leftarrow \\mathcal{G}()$ (private signing key, public verifying key) and sends $pk$ to $\\mathcal{A}$.\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* $\\mathcal{A}$ queries the challenger several times. For $i = 1, 2, \\dots$, the $i^{th}$ signing query is a message $m_i \\in \\mathcal{M}$. Given $m_i$, the challenger computes $\\sigma_i \\leftarrow \\mathcal{S}(sk, m_i)$, and then gives $\\sigma_i$ to $\\mathcal{A}$.\n\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* Eventually $\\mathcal{A}$ outputs a candidate forgery pair $(m, \\sigma) \\in \\mathcal{M} \\times \\Sigma$.\n\n# [Cryptobook](https://toc.cryptobook.us/book.pdf):\n\n**Attack Game 13.1 (Signature security).** For a given signature scheme $\\mathcal{S} = (\\mathcal{G}, \\mathcal{S}, \\mathcal{V})$, (generate, sign, verify) defined over $(\\mathcal{M}, \\Sigma)$, (messages, signatures), and a given adversary $\\mathcal{A}$, the attack game runs as follows:\n\n* We say that the adversary wins the game if the following two conditions hold:\n\n$$\n\\mathcal{V}(pk, m, \\sigma) = \\text{accept}\n$$\n\n# Techniques\n\n*   **Define the scope** and depth of analysis.\n*   Gain a **visual understanding** of what you’re threat modeling.\n*   Visually **model** the attack possibilities.\n*   **Identify** threats.\n*   **Document** of missing or weak security controls.\n\n# Scope\n\n*   Determine **stakeholders**\n    *   Who uses the service?\n    *   Who provides the service?\n    *   Who benefits from the service?\n    *   Who does not benefit from the service?\n\n# Scope\n\n*   Who can answer these questions?\n    *   Are they the same or different people?\n    *   Should you do this by yourself?\n    *   What do you do if you need help?\n\n# Visuals\n\n```{dot}\n//| fig-width: 1000px\n//| output-location: slide\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=record\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=\"{h(prev)|<here> h(root)}|{time|nonce}\"]\n  0 [label=\"{<there> h(prev)|<here> h(root)}|{time|nonce}\"]\n  2 [label=\"{<there> h(prev)|<here> h(root)}|{time|nonce}\"]\n  merkle [label=\"{<1> 0x1|h(*0x2,*0x3)}|{0x2|h(*0x4,*0x5)}|{0x3|h(*0x6,*0x7)}|{0x4|h(*0x8,*0x9)}|{0x5|h(*0xA,*0xB)}|{0x6|<6> h(G,C,2)}|{0x7|<7> h(A,G,4)}|{0x8|<8> h(A,B,1)}|{0x9|<9> h(B,C,2)}|{0xA|<A> h(C,D,3)}|{0xB|<B> h(F,A,7)}\"]\n  \n  heap [shape=record, label=\"{send|recv|amnt}|{<e> G|C|2}|{<f> A|G|4}|{<a> A|B|1}|{<b> B|C|2}|{<c> C|D|3}|{<d> F|A|7}\"]\n\n  1 -> 0:there\n  0 -> merkle:1\n  0 -> 2:there\n  merkle:7 -> heap:f\n  merkle:6 -> heap:e\n  merkle:B -> heap:d\n  merkle:A -> heap:c\n  merkle:9 -> heap:b\n  merkle:8 -> heap:a\n\n}\n```\n\n\n\n# Threats\n\n*   What if?\n    - Someone changes `(G,C,2)` to `(G,C,3)`\n    - `G` submits a second `(G,G,2)` next block\n    - `G` loses their private key?\n\n# Document\n\n- [https://bitcoin.org/bitcoin.pdf](https://bitcoin.org/bitcoin.pdf)\n- [https://github.com/bitcoin/bitcoin](https://github.com/bitcoin/bitcoin)\n\n# **Traffic light**\n\n*   **Diagram:** What are we building?\n*   **Identify threats:** What could go wrong?\n*   **Mitigate:** What are we doing to defend against threats?\n*   **Validate:** Have we acted on each of the previous steps?\n\n# Today\n\n- &check; Threat and Threat Models\n- (Trace) Properties\n- Kripke Structures\n- Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n# Properties\n\n*   An **security policy** may have **properties**.\n*   These **security policies** are distinct from the **what?** of a threat model\n*   Rather the **security policy** is the **how?** of a threat model\n\nA security policy could have the property of being **secure** if the threats of a threat model are mitigated\n\n# Trace Properties\n\n*   I think of properties in terms of **traces**\n*   A **trace** is the sequence of states through which a system passes over time.\n    *   A **sequence** is an ordered collection.\n    *   A **state** is the configuration of a system at some specific time point.\n    *   A **system** implements the security policy.\n    *   Emphasize the notion of **over time**. Traces are **time-based**.\n\n# Traffic Light\n\n*   Think of a **traffic light**.\n    *   In what **states** may a traffic light be?\n    *   In what **sequence** may these states occur?\n    *   Does a traffic light implement a **security policy**\n    *   Do traffic lights **change over time**?\n\n# State Machine\n\n- A traffic light is a **state machine**.\n\n> [A **state machine** is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time.](https://en.wikipedia.org/wiki/Finite-state_machine)\n\n- Often called \"FSM\" (finite state machine)\n    - I don't have a hot new start-up selling infinite states.\n\n# A Trace\n\n- We can denote the state of a traffic light by the lit color. (\"Wow this class is lit.\")\n- A trace may appear as:\n\n```{.python}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n# Examples\n\n- Let's review some traces and see if they are from a traffic light system that is operating properly.\n```{.python}\nsummarize = lambda t : \"\".join([s[0] for s in t])\n```\n- Can also express traces as e.g. `RGYRGYRGY`\n\n# Start\n\n- Does **starting state** matter?\n\n::::{columns}\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n\n```{.python}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\"\n]\n```\n\n:::\n\n::::\n\n# End\n\n- Does **ending state** (terminating state) matter?\n\n   \n::::{columns}\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n\n```{.python}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\"\n]\n```\n\n:::\n\n::::\n\n# Length\n\n- Does **length** (or perhaps size) matter?\n\n   \n::::{columns}\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"YELLOW\",\n    \"RED___\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n\n```{.python}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\",\n    \"RED___\"\n]\n```\n\n:::\n\n::::\n\n\n# Unique\n\n- Does **number of unique states** matter?\n\n   \n::::{columns}\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"YELLOW\",\n]\n```\n\n:::\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n\n```{.python}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n::::\n\n\n\n# Order\n\n- Does **order** matter?\n\n   \n::::{columns}\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"GREEN_\",\n    \"RED___\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n  \n```{.python}\ntrace = [\n    \"RED___\",\n    \"YELLOW\",\n    \"GREEN_\"\n]\n```\n\n:::\n\n:::{.column width=33%}\n\n```{.python}\ntrace = [\n    \"RED___\",\n    \"GREEN_\",\n    \"YELLOW\"\n]\n```\n\n:::\n\n::::\n\n# Sets of Traces\n::: {.callout-note}\nA **trace property** is a set of traces.\n:::\n\n- Say, variable \"property\" is a list of traces.\n    - *Should* be a set.\n```{.py}\nproperty[0] = [\"GREEN_\"]\nproperty[1] = [\"YELLOW\"]\nproperty[2] = [\"RED___\"]\nproperty[3] = [\"GREEN_\", \"YELLOW\"]\n```\n    \n\n# System Properties\n\n*   Say a system \"satisfies\" property $p$ if all possible traces produced by a system are in the property.\n*   This may be an infinite number of traces or include traces of infinite length.\n*   Systems may have (satisfy) more than one property.\n\n# On Security\n\nProperties provide a way to answer the \"How?\" after asking:\n\n*   **What** is secure?\n*   **For whom** is the 'what' secure?\n*   **From whom** is the 'what' secure?\n\n# Sets of Traces\n\n- A **set** is an ordered collection of elements (such as sequences).\n- A **sequence** is an ordered collection of elements (such as states).\n- A **trace property** is a set of traces.\n- A **trace** is a sequence of states.\n\n# Organization\n\n\n```{dot}\n//| echo: false\n//| fig-width: 1000px\ndigraph PropertyHierarchy {\n  bgcolor=\"#191919\";\n  node [shape=box, style=rounded, fontcolor=white, color=white];\n  edge [color=white];\n\n  PROPERTY [label=\"PROPERTY\\nSet of traces\"];\n  SET [label=\"SET\\nUnordered elements\"];\n  TRACE [label=\"TRACE\\nSequence of states\"];\n  SEQUENCE [label=\"SEQUENCE\\nOrdered elements\"];\n  STATES [label=\"STATES\\nDescribe a system at\\nsome time\"];\n\n  PROPERTY -> SET;\n  PROPERTY -> TRACE;\n  TRACE -> SEQUENCE;\n  TRACE -> STATES;\n}\n```\n\n\n# Example\n\n\n```{dot}\n//| echo: false\n//| fig-width: 1000px\ndigraph PropertyHierarchy {\n  bgcolor=\"#191919\";\n  node [shape=box, style=rounded, fontcolor=white, color=white];\n  edge [color=white];\n\n  PROPERTY [label=\"PROPERTY\\n{R,YR,GYR,RGYR}\"];\n  SET [label=\"SET\\nUnordered elements\"];\n  TRACE [label=\"TRACE\\nRGYR\"];\n  SEQUENCE [label=\"SEQUENCE\\nOrdered elements\"];\n  STATES [label=\"STATES\\n{RED___, GREEN_}\"];\n\n  PROPERTY -> SET;\n  PROPERTY -> TRACE;\n  TRACE -> SEQUENCE;\n  TRACE -> STATES;\n}\n```\n\n\n# Enumeration\n\n- Thus far, we enumerated the possible traces.\n```{.python}\nproperty[0] = [\"GREEN_\"]\nproperty[1] = [\"YELLOW\"]\nproperty[2] = [\"RED___\"]\nproperty[3] = [\"GREEN_\", \"YELLOW\"]\n```    \n\n- This is bad. Why?\n\n# Specification\n\n- Rather than enumerate, let us specify.\n\n```{.email}\nThe traffic light property is\n    the set of all sequences over precisely the states {\"GREEN_\", \"YELLOW\", \"RED___\"} such that \n        the only state succeeding \"GREEN_\" is \"YELLOW\" and\n        the only state succeeding \"YELLOW\" is \"RED___\" and\n        the only state succeeding \"RED___\" is \"GREEN_\".\n```\n    \n# Today\n\n- &check; Threat and Threat Models\n- &check; (Trace) Properties\n- Kripke Structures\n- Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n\n# Model Checking\n\n- A Kripke Structure is a tuple that models a state machine.\n- Recall:\n    - A **state machine** is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time.\n    - Exactly one!\n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, ...} that models a state machine.\n\n*   _S_ is a finite set of states\n    *   Kripke structures only work for **finite** state machines\n    *   For the sake of this class, we can imagine infinite states if needed.\n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, ...} that models a state machine.\n\n*   For a traffic light, _S_ is:\n`{\"GREEN_\", \"YELLOW\", \"RED___\"}`\n    \n*   For a Bitcoin, it is perhaps the current owner.\n    *   Many possible, but finite, number of owners.\n        \n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, _I_, ...} that models a state machine.\n\n*   _I_ is a subset of _S_, we denote this _I_ ⊂ _S_\n    *   Any state in _I_ must be a state in _S_\n    *   There may be states in _S_ that are not in _I_\n    *   These are the possible initial states of the state machine.\n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, _I_, ...} that models a state machine.\n\n*   For a traffic light, _I_ = _S_ `{\"GREEN_\", \"YELLOW\", \"RED___\"}`\n    \n*   For a Bitcoin, the initial state is Satoshi Nakamoto's public key.\n        \n# Model Checking\n\nA Kripke Structure is a tuple {_S_, _I_, ...} that models a state machine.\n\n*   _S_ is a finite set of states\n*   _I_ ⊂ _S_ is the set of initial states.\n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   _R_ is a **transition relation** over _S_, we denote this _R_ ⊂ _S_ × _S_\n    *   This just means _R_ says whether one state may be transitioned to from another.\n    *   Same as graph edges (if we take _S_ to be nodes)\n\n# Model Checking\n\n*   **BONUS/CHALLENGE:** _R_ is left-total.\n\n:::{.callout-note}    \nA binary relation _R_ ⊂ _S_ × _S_ is **left-total** if for all elements _s_ of _S_ there exists some ordered pair in _R_ such that the first element of the ordered pair is _s_.\n:::\n    \n* _R_ ⊂ _S_ × _S_ is **left-total** ≔ ∀ _s1_ ∈ _S_, ∃ _s2_ ∈ _S_ such that (_s1_,_s2_) ∈ _R_\n    \n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   For a traffic light, _R_ is:\n```{.py}\n{(\"GREEN_\", \"YELLOW\"),\n (\"YELLOW\", \"RED___\"),\n (\"RED___\", \"GREEN_\")}\n```\n*   For Bitcoin, the Cartesian product.\n\n# Model Checking\n\nA Kripke Structure is a tuple {_S_, _I_, _R_, ...} that models a state machine.\n\n*   _S_ is a finite set of states\n*   _I_ ⊂ _S_ is the set of initial states.\n*   _R_ ⊂ _S_ × _S_ is a left-total transition relation.\n\n# Model Checking\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models a state machine.\n\n*   _L_ is a **labeling function** over _S_, we denote this _L_ ⊂ _S_ → ???\n    *   This just means _L_ provides a way of talking about the states in _S_\n    *   We talk about these states using **atomic propositions**\n\n# Atomic Propositions\n\n*   Propositions are expressions in propositional, or zeroth order, logic.\n*   They are simply true or false.\n*   Atomic propositions are simplest possible form of these logic expressions.\n*   _L_ ⊂ _S_ → 2<sup>_AP_</sup>\n\n# Model Checking\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions between over atomic propositions _AP_.\n\n*   _L_ is a **labeling function** over _S_, we denote this _L_ ⊂ _S_ → 2_AP_\n    *   Given _AP_, _L_ tells us whether each is `true` or `false` (2 options) for every given state.\n\n# Model Checking\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   For a traffic light, regard _AP_ as the bit encoding of the current state, with perhaps bits encoding \"redness\", \"yellowness\", and \"greenness\"\n*   These happen to be but are not required to be mutually exclusive. \n\n# AP\n\n* Or just take a \"red\" and \"green\" proposition.\n*   The easiest way to imagine this is with hexcodes\n```{.python}\nred    = 0xFF0000\ngreen  = 0x00FF00\nyellow = red + green\n```\n* Regard a yellow light as a light that is both red and green (after all... it is)\n    \n# Model Checking\n\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   _S_ is a finite set of states\n*   _I_ ⊂ _S_ is the set of initial states.\n*   _R_ ⊂ _S_ × _S_ is a left-total transition relation.\n*   _L_ ⊂ _S_ → 2_AP_ is the labelling relation.\n\n<!--\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   _S_ is a finite set of states and _I_ ⊂ _S_ is the set of initial states.\n\n    {\"GREEN_\", \"YELLOW\", \"RED___\"}\n\n*   _R_ ⊂ _S_ × _S_ is a left-total transition relation.\n\n    {(\"GREEN_\", \"YELLOW\"), \n     (\"YELLOW\", \"RED___\"), \n     (\"RED___\", \"GREEN_\")}\n\n*   _L_ ⊂ _S_ → 2_AP_ is the labelling relation.\n\n    {(\"GREEN_\", {p, s, u}),\n     (\"YELLOW\", {q, s, t}), \n     (\"RED___\", {r, t, u})}\n\nA Kripke Structure modelling a traffic light is the 4-tuple...\n\n    ({\"GREEN_\", \"YELLOW\", \"RED___\"}, \n     {\"GREEN_\", \"YELLOW\", \"RED___\"}, \n     {(\"GREEN_\", \"YELLOW\"), \n      (\"YELLOW\", \"RED___\"), \n      (\"RED___\", \"GREEN_\")}, \n     {(\"GREEN_\", {p, s, u}),\n      (\"YELLOW\", {q, s, t}), \n      (\"RED___\", {r, t, u})})\n\n...over _AP_...\n\n    [p : state == \"GREEN_\",  \n     q : state == \"YELLOW\",  \n     r : state == \"RED___\",  \n     s : state ∈ {\"GREEN_\", \"YELLOW\"},\n     t : state ∈ {\"YELLOW\", \"RED___\"},\n     u : state ∈ {\"RED___\", \"GREEN_\"}]\n\nModel Checking\n--------------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_} that models transitions and _AP_.\n\n*   This is still bad. Why?\n\n-->\n\n# Diagrams\n\nNow that I've rigorously defined Kripke Structures, I am willing to tell you they are just diagrams.\n\n*   Clarke, Edmund & Grumberg, Orna & Jha, Somesh & Lu, Yuan & Veith, Helmut. (2003). Counterexample-guided abstraction refinement for symbolic model checking. J. ACM. 50. 752-794. 10.1145/876638.876643.\n\n# Diagrams\n\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n    - $S := \\{ S_1, S_2, S_3 \\}$\n    - $I := \\{ S_1 \\}$\n    - $R := \\{(1,2), (2,1), (2,3), (3,3)\\}$\n    - $L := \\{({p,q},1), ({q},2), ({p},3)\\}$\n\n:::\n\n:::{.column width=50%}\n\n<a style=\"filter:invert(1)\" title=\"Original file: Ashutosh y0078\nUpdated version: Ixfd64, CC BY 3.0 &lt;https://creativecommons.org/licenses/by/3.0&gt;, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:KripkeStructureExample.svg\"><img width=\"100%\" alt=\"KripkeStructureExample\" src=\"https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg\"></a>\n\n:::\n\n::::\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n}\n```\n\n\n:::\n\n::::\n\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n    - $S := \\{ S_1, S_2, S_3 \\}$\n        - Denote states as numbered circles.\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<S<SUB>1</SUB>>]\n  2 [label=<S<SUB>2</SUB>>]\n  3 [label=<S<SUB>3</SUB>>]\n}\n```\n\n\n:::\n\n::::\n\n\n\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n    - $S := \\{ S_1, S_2, S_3 \\}$\n    - $I := \\{ S_1, S_2, S_3 \\}$\n        - Denote as incoming arrows\n\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  01 [label=\"\", shape=point]\n  1 [label=<S<SUB>1</SUB>>]\n  01 -> 1\n  02 [label=\"\", shape=point]\n  2 [label=<S<SUB>2</SUB>>]\n  02 -> 2\n  03 [label=\"\", shape=point]\n  3 [label=<S<SUB>3</SUB>>]\n  03 -> 3\n}\n```\n\n\n:::\n\n::::\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n    - Skip to labels\n    - Basically have:\n        - $\\{r\\}$\n        - $\\{g\\}$\n        - $\\{r,g\\}$\n    - Just use that order.\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  01 [label=\"\", shape=point]\n  1 [label=<S<SUB>1</SUB><br/><br/>{ r }>]\n  01 -> 1\n  02 [label=\"\", shape=point]\n  2 [label=<S<SUB>2</SUB><br/><br/>{ g }>]\n  02 -> 2\n  03 [label=\"\", shape=point]\n  3 [label=<S<SUB>3</SUB><br/><br/>{r,g}>]\n  03 -> 3\n}\n```\n\n\n:::\n\n::::\n\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n    - The state names are not meaningful\n    - I can make them whatever I want via $L$\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  01 [label=\"\", shape=point]\n  1 [label=<R<br/>{ r }>]\n  01 -> 1\n  02 [label=\"\", shape=point]\n  2 [label=<G<br/>{ g }>]\n  02 -> 2\n  03 [label=\"\", shape=point]\n  3 [label=<Y<br/>{r,g}>]\n  03 -> 3\n}\n```\n\n\n:::\n\n::::\n\n\n\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n- We have our transition relation.\n- Side-to-top\n\n||R|G|Y|\n|-|-|-|-|\n|R||x||\n|G|||x|\n|Y|x|||\n\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<R<br/>{ r }>]\n  2 [label=<G<br/>{ g }>]\n  3 [label=<Y<br/>{r,g}>]\n\n  1 -> 2\n  2 -> 3\n  3 -> 1\n  01 [label=\"\", shape=point]\n  02 [label=\"\", shape=point]\n  03 [label=\"\", shape=point]\n  02 -> 2\n  01 -> 1\n  03 -> 3\n}\n```\n\n\n:::\n\n::::\n\n\n\n# Traffic Light\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- $\\{S, I, R, L\\}$\n- Perhaps omit $I$ denotation.\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<R<br/>{ r }>]\n  3 [label=<Y<br/>{r,g}>]\n  2 [label=<G<br/>{ g }>]\n\n  3 -> 1\n  2 -> 3\n  1 -> 2\n}\n```\n\n\n:::\n\n::::\n\n# Acceptance\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- We say a trace is accepted if\n    - It starts in a start state, and\n    - For each new tracepoint, there is an edge.\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<R<br/>{ r }>]\n  3 [label=<Y<br/>{r,g}>]\n  2 [label=<G<br/>{ g }>]\n\n  3 -> 1\n  2 -> 3\n  1 -> 2\n}\n```\n\n\n:::\n\n::::\n\n# Acceptance\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- `R` is accepted.\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<R<br/>{ r }>]\n  3 [label=<Y<br/>{r,g}>]\n  2 [label=<G<br/>{ g }>]\n\n  0 [label=\"\", shape=\"point\"]\n  0 -> 1 [color = \"#ffa07a\"]\n  3 -> 1\n  2 -> 3\n  1 -> 2\n}\n```\n\n\n:::\n\n::::\n\n\n# Acceptance\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- `RG` is accepted.\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<R<br/>{ r }>]\n  3 [label=<Y<br/>{r,g}>]\n  2 [label=<G<br/>{ g }>]\n\n  0 [label=\"\", shape=\"point\"]\n  0 -> 1 [color = \"#ffa07a\"]\n  3 -> 1 \n  2 -> 3 \n  1 -> 2 [color = \"#ffa07a\"]\n}\n```\n\n\n:::\n\n::::\n\n\n# Rejection\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- `RY` is a rejected.\n    - No edge from `R` to `Y`\n\n:::\n\n:::{.column width=50%}\n\n\n```{dot}\n//| fig-width: 400px\n//| echo: false\ndigraph block_chain {\n  rankdir=TD;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n      shape=circle\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  1 [label=<R<br/>{ r }>]\n  3 [label=<Y<br/>{r,g}>]\n  2 [label=<G<br/>{ g }>]\n\n  0 [label=\"\", shape=\"point\"]\n  0 -> 1 [color = \"#ffa07a\"]\n  3 -> 1 \n  2 -> 3 \n  1 -> 2\n  1 -> 3 [style=\"dashed\", color=\"red\"]\n}\n```\n\n\n:::\n\n::::\n\n<!--\nDiagrams\n--------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_}\n\n*   _S_ is the states, in blue.\n\nDiagrams\n--------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_}\n\n*   _S_ is the states, in blue.\n*   _I_ is the inital states, in orange.\n*   _R_ is the relations, in purple.\n\nDiagrams\n--------\n\nA Kripke Structure is a 4-tuple {_S_, _I_, _R_, _L_}\n\n*   _S_ is the states, in blue.\n*   _I_ is the inital states, in orange.\n*   _R_ is the relations, in purple.\n*   _L_ is the labels, in black.\n\n\n-->\n\n# Limitations\n\n- Better than enumeration, but...\n    *   In text is too complex\n    *   Considering traces is difficult in nontrivial cases.\n- We will introduce a better way to write out relations, then look at our Kripke Structures.\n\n\n# TCP\n\n- Consider the \"famous\" TCP 3-way handshake.\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png\" style=\"filter:invert(.9)\">\n\n- [More](https://www.geeksforgeeks.org/tcp-3-way-handshake-process/)\n\n\n\n# TCP\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- State is more complex.\n    - Tracking whether `SYN` and `ACK` have been received by both client and server.\n\n:::\n\n:::{.column width=50%}\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png\" style=\"filter:invert(.9)\">\n\n:::\n\n::::\n\n# TCP\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- Transitions are more complex.\n    - Vs, a light which *is* red and *becomes* red.\n    - A server *is* in state, say `LISTEN` and then transitions to state `SYN-RECEIVED`.\n\n:::\n\n:::{.column width=50%}\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png\" style=\"filter:invert(.9)\">\n\n:::\n\n::::\n\n# TCP\n\n::::{columns}\n\n:::{.column width=50%}\n  \n- Is this trace accepted?\n    1. `Client.SYN`\n    2. `Client.SYN` x2\n    3. `Server.SYN`\n    4. `Server.ACK`\n    5. `Client.ACK`\n\n:::\n\n:::{.column width=50%}\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png\" style=\"filter:invert(.9)\">\n\n:::\n\n::::\n\n<!--\n\n\nA concretization\n----------------\n\nConsider the following representation:\n\n*   Take `p` to be \"password checking is blocked/secured\"\n*   Take `q` to be \"system access is blocked/secured\"\n\nA passwording service **must** disclose if an entered password is correct.\n\n*   `p` and `q` are true initially.\n    *   No checking, no access\n*   Once `q` becomes false, it never becomes true again.\n    *   Once logged in, we can no longer guess passwords.\n*   Once `q` becomes false, `p` stays true forever.\n    *   Once logged in, access is not revoked.\n\nInfinite guesses (bad), but persistent users may not look up passwords (good).\n\nGoals\n-----\n\nWe have:\n\n*   A way to describe the current state of the system (_AP_)\n\nWe need:\n\n*   A way to describe relations between atomic propositions over time.\n\nConsider:\n\n*   `p` and `q` are true **initially**.\n*   Once `q` becomes false, it never becomes true again.\n    *   `q` until not `q`\n*   Once `q` becomes false, `p` stays true forever.\n    *   `q` until not `q`\n*   `p` goes from false to true when `q` goes from true to true false.\n\n-->\n    \n# TCP\n\n::::{columns}\n\n:::{.column width=50%}\n\n*   Server/Client requires `SYN` initially.\n*   Server may not 'SYN' or `ACK` until seeing `SYN`\n*   Client may not `ACK` until seeing `ACK`\n*   Client must `ACK`\n\n:::\n\n:::{.column width=50%}\n\n<img src=\"https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png\" style=\"filter:invert(.9)\">\n\n:::\n\n::::\n\n# Today\n\n- &check; Threat and Threat Models\n- &check; (Trace) Properties\n- &check; Kripke Structures\n- Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n# neXt and Until\n\n- It often suffices to define two temporal operators:\n\n    *   **X**: “neXt”\n    *   **U**: “Until”\n\n- Along with existing logical operators:\n\n    *   **¬**: “not”\n    *   **∨**: “or”\n\n- Apply these over atomic propositions in _AP_ to describe security.\n\n# Composition\n\nWith logical negation (not) and disjunction (or) we can generate other logical connectives.\n\n| $p$     | $q$     | $\\neg p$    | $p \\lor q$   | $\\neg p \\lor \\neg q$ | $\\neg p \\lor \\neg q \\equiv p \\land q$ |\n| :---- | :---- | :---- | :---- | :---- | :------------ |\n| True  | True  | False | True  | False | True          |\n| True  | False | False | True  | True  | False         |\n| False | True  | True  | True  | True  | False         |\n| False | False | True  | False | True  | False         |\n\n\n# Next and Until\n\n\n<img src=\"https://cd-public.github.io/courses/old/secs24/slides/images/xu.png\" style=\"filter:invert(.9)\">\n\n# Derived Unary\n\n| Name           | Written:         | Meaning                                                                    | Equivalencies                 |\n| :------------- | :------------ | :------------------------------------------------------------------------- | :---------------------------- |\n| neXt           | **X** _p_      | _p_ holds in the next time                                                | **X** _p_                    |\n| Future         | **F** _p_      | _p_ holds in some future time                                             | True **U** _p_              |\n| Global(ly)     | **G** _p_      | _p_ holds future times                                              | **¬**(True **U** **¬** _p_) |\n\n# Derived Binary\n\n| Name           | Written:         | Meaning                                                                    | Equivalencies                 |\n| :------------- | :------------ | :------------------------------------------------------------------------- | :---------------------------- |\n| Until          | _p_ **U** _q_ | _p_ holds unless _q_, _q_ must hold eventually        | _p_ **U** _q_                |\n| Release        | _p_ **R** _q_ | _q_ holds up to and including when _p_ holds                               | **¬**(**¬** _p_ **U** **¬** _q_) |\n\n# Special Binary\n\n| Name           | Written:       | Meaning                                                                    | Equivalencies                 |\n| :------------- | :------------ | :------------------------------------------------------------------------- | :---------------------------- |\n| Weak until     | _p_ **W** _q_ | _p_ holds up to when _q_ holds                                             | (_p_ **U** _q_) ∨ **G** _p_  |\n| Mighty release | _p_ **M** _q_ | _q_ holds up to and including when _p_ holds, and _p_ must hold eventually | _q_ **U** (_p_ **∨** _q_) |\n\n\n# Properties\n\n*   Some security properties are about bad things not happening:\n    *   **G** $\\neg$ _bad_\n    *   Term this \"safety\"\n*   Some security properties are about good things happening someday:\n    *   **F** _good_\n    *   Term this \"liveness\"\n\n# Today\n\n- &check; Threat and Threat Models\n- &check; (Trace) Properties\n- &check; Kripke Structures\n- &check; Linear Temporal Logic\n- Büchi Automata\n    - DFAs\n    - Safety & Liveness\n- CIA Triad\n\n# Aside\n\n- Büchi Automata are just \"DFA\" (deterministic finite automata) that aren't finite.\n- They accomplish this through an uninteresting hack.\n- DFAs are the first automata taught in theory of computing and automata theory class.\n- The follow slides conclude the \"sets/graphs/automata\" portion of class, among other things.\n<!--\nBüchi Automata\n--------------\n\n*   Logicians use Büchi Automata to define **safety** and **liveness** more formally.\n*   Büchi Automata are more expressive than Kripke Structures\n*   Deterministic Büchi Automata are equivalent to LTL\n    *   What would it mean for a Kripke Structure to be deterministic?\n    *   What would it mean for LTL not to be deterministic?\n\n\n\n# Büchi Automata\n\nA deterministic Büchi Automaton either accepts or rejects infinite inputs (traces).\n\n# Büchi Automata\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, ...} that accepts traces.\n\n*   _Q_ is a finite set.\n    *   We term the elements of _Q_ to be the states of _A_\n    *   The states of _A_ may be distinct from the unique states found within a trace.\n    *   Traces of infinite length can be considered.\n*   _Q_ is circles in our diagram.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_,...} that accepts traces.\n\n*   _Σ_ (sigma) is a finite set.\n    *   We term _Σ_ the alphabet of _A_\n    *   _Σ_ is the unique states found within a trace.\n    *   We use _Σ_ ω (upper case sigma raised to lower case omega) to denote infinite traces\n    *   These are the possible states of a trace; I term them letters.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_,...} that accepts traces _Σ_ ω.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n\nWe studied example traces earlier, for these:\n\n    Σ = { {'p', 'q'}, {'p'}, {'q'} }\n\nWe cannot yet generate something that looks like _Q_, but it is similar to\n\n    Q ≈ {'s_1', 's_2', 's_3'}\n\n![](https://upload.wikimedia.org/wikipedia/commons/3/3b/KripkeStructureExample.svg)\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, ...} that accepts traces _Σ_ ω.\n\n*   _δ_ is a function.\n    *   We term _δ_ (lower case delta) the transition function of _A_.\n    *   _δ_ maps combinations of states and letters to other states.\n    *   _δ_ : _Q_ × _Σ_ **→** _Q_, or\n    *   _δ_ ⊆ (_Q_ × _Σ_ ) × _Q_\n*   _δ_ is like Kripke _R_ except that it has to check both _Q_ (model) and _Σ_ (trace).\n*   _δ_ takes a circle in the diagram and an observation and tells you the new circle in the diagram.\n*   _Σ_ labels arrows between circles in the diagram.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_,...} that accepts traces.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ is a function: the transition function of _A_.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_,...} that accepts traces _Σ_ ω.\n\n*   _q0_ ∈ _Q_ (say: q-naut is an element of the seq Q)\n    *   We term _q0_ the initial state of _A_.\n    *   _q0_ is like _I_ but Büchi Automata have only a single starting state.\n        *   This is because Büchi Automata have no atomic proposition labels on states, only on transitions.\n    \n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_,...} that accepts traces _Σ_ ω.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ is a function: the transition function of _A_.\n*   _q0_ ∈ _Q_: is a state: the initial state of _A_\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_, **F** } that accepts traces _Σ_ ω.\n\n*   **F** ⊆ _Q_ is a non-strict subset.\n    *   We term **F** the acceptance condition.\n    *   This one looks a bit odd on slides, it looks clearer standard formatting.\n        *   **F** is bolded\n        *   _Q_ is italicized\n        *   F ⊆ Q|\n    *   An infinite trace must visit states in **F** an infinite number of times to be accepted.\n    *   We can think of finite traces as infinitely repeated their last state, which must be in **F**.\n\nBüchi Automata\n--------------\n\nA deterministic Büchi Automaton _A_ is a tuple {_Q_, _Σ_, _δ_, _q0_, **F** } that accepts traces _Σ_ ω.\n\n*   _Q_ is a finite set: the states of _A_.\n*   _Σ_ is a finite set: the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ is a function: the transition function of _A_.\n*   _q0_ ∈ _Q_: is a state: the initial state of _A_\n*   **F** ⊆ _Q_ is a non-strict subset: the acceptance condition\n\n-->\n\n\n# Finite Automata\n\n## Definition\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n- Term this $M_1$:\n    - States\n     $$\n     q_n\n     $$\n\n    - Transitions \n    $$\n    \\overset{\\{1\\}}{\\longrightarrow}\n    $$\n    - Start state $q_1$\n    - Accept state $q_3$\n\n:::\n\n::: {.column width=\"50%\"}\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 500px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n:::\n\n::::\n\n## Process\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n:::{.nonincremental}\n\n- Term this $M_1$:\n    - States\n     $$\n     q_n\n     $$\n\n    - Transitions \n    $$\n    \\overset{\\{1\\}}{\\longrightarrow}\n    $$\n    - Start state $q_1$\n    - Accept state $q_3$\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n- **Input**\n    - *Finite* bit string \n    -   $\\{0,1\\}^n$\n- **Output**\n    - Boolean or bit\n    -   $\\{0,1\\}$\n-   Begin in start\n-   Read symbol\n-   Follow edge\n\n:::\n\n::::\n\n\n## ''\n\n- The inital state is $q_1$.\n\n```py\n[] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, color=\"orange\"];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 [color=\"orange\"]\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n\n## '0'\n\n- Find label containing `0` out of $q_1$.\n\n```py\n[0] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, color=\"orange\"];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\", color=\"orange\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## '01'\n\n- Find label containing `1` out of $q_1$.\n\n```py\n[0, 1] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, color=\"orange\"];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\", color=\"orange\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## '011'\n\n- Find label containing `1` out of $q_2$.\n\n```py\n[0, 1, 1] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\", color=\"orange\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## '0110'\n\n- Find label containing `0` out of $q_3$.\n\n```py\n[0, 1, 1, 0] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\", color=\"orange\"];\n}\n```\n\n\n## '01101'\n\n- Find label containing `1` out of $q_3$.\n\n```py\n[0, 1, 1, 0, 1] # We'll use a Python list to represent the input.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\", color=\"orange\"];\n}\n```\n\n\n## '01101'\n\n- $M_1$ accepts `[0, 1, 1, 0, 1]` by ending in $q_3$\n\n```py\nassert(M_1([0, 1, 1, 0, 1]) # M_1 as a function from bit strings to booleans.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>, color=\"orange\"];\n  q2 [label=<<I>q<SUB>2</SUB></I>>, color=\"orange\"];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle, color=\"orange\"]; \n\n  q0 -> q1 [color=\"orange\"]\n  q1 -> q1 [label=\"{0}\", color=\"orange\"];\n  q1 -> q2 [label=\"{1}\", color=\"orange\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\", color=\"orange\"];\n  q3 -> q3 [label=\"{0,1}\", color=\"orange\"];\n}\n```\n\n\n## Exercise\n\n- Does $M_1$ accept `[0, 0, 1, 0, 1]`?\n\n```py\n[0, 0, 1, 0, 1] # M_1 as a function from bit strings to booleans.\n```\n\n\n```{dot filename=\"Finite Automata\"}\n//| fig-width: 800px\n//| echo: false\ndigraph finite_automata {\n  rankdir=LR;\n  bgcolor=\"#191919\";\n\n  node [\n      fontcolor = \"#ffffff\",\n      color = \"#ffffff\",\n  ]\n\n  edge [\n      color = \"#ffffff\",\n      fontcolor = \"#ffffff\"\n  ]\n\n  node [shape=circle];\n  q0 [label=\"\",shape=point]; \n  q1 [label=<<I>q<SUB>1</SUB></I>>];\n  q2 [label=<<I>q<SUB>2</SUB></I>>];\n  q3 [label=<<I>q<SUB>3</SUB></I>>, shape=doublecircle]; \n\n  q0 -> q1 []\n  q1 -> q1 [label=\"{0}\"];\n  q1 -> q2 [label=\"{1}\"];\n  q2 -> q1 [label=\"{0}\"];\n  q2 -> q3 [label=\"{1}\"];\n  q3 -> q3 [label=\"{0,1}\"];\n}\n```\n\n\n## Terminology\n\n- We say that:\n    -   $A$ is the *language* of $M_1$.\n    -   $M_1$ *recognizes* $A$\n    -   $A = L(M_1)$\n- We note:\n$$\nw \\in A \\implies \\exists i < |w| - 1 : w_i = 1 \\land w_{i+1} = 1 \n$$\n\n:::{.fragment}\n\n```{.py}\nw = '01101' # for example\nassert('11' in w)\n```\n\n:::\n\n# Formal Definition\n\n## Finite Automaton\n\n> A **finite automaton** (FA), also known as a finite state machine (FSM), is a mathematical model of computation used to recognize patterns in a sequence of symbols. \n    \n\n## Finite Automaton  \n  \n- In class: \"finite automaton\"\n- Real life: mostly say \"state machine\"\n- I used the notation *FA to denote these are not a specific kind of FA\n\n\n## Formal Definition\n\nA finite automaton is formally defined as a 5-*tuple*:\n\n- **$Q$** A finite, non-empty *set* of states.\n- **$\\Sigma$:** A finite, non-empty *set* of input symbols called the alphabet.\n- **$\\delta$:** The transition function, a mapping \n    -   $\\delta : Q \\times \\sigma \\rightarrow Q$ \n- **$q_0$:** The initial state, where $q_0 \\in Q$.\n- **$F$:** A set of accepting states (or final states), where $F \\subset Q$.\n\n## Explanation:\n\n* **States ($Q$):** Possible internal configurations - like computer memory.\n* **Alphabet ($\\Sigma$):** Possible inputs - machine binary or computer I/O.\n* **Transition Function ($\\delta$):** How the FA's state is updated on read.\n* **Initial State ($q_0$):** This is the state where the automaton begins its operation.\n* **Accepting States ($F$):** These determine if the FA outputs $0$ or $1$.\n\n## Our Example\n\n- $M_1 = (Q, \\Sigma, \\delta, q_1, \\{q_3\\})$\n    - $Q = \\{q_1, q_2, q_3\\}$\n    - $\\Sigma = \\{0, 1\\}$\n- How to express $\\delta$?\n\n:::{.fragment}\n\n| $\\delta=$  | $0$ | $1$ |\n|------------|-----|-----|\n| $q_1$&vert;|$q_1$|$q_2$|\n| $q_2$&vert;|$q_1$|$q_3$|\n| $q_3$&vert;|$q_3$|$q_3$|\n\n:::\n\n## Python\n\n::: {#3556f2a8 .cell execution_count=2}\n``` {.python .cell-code}\n# define q_n as a convenience\nq_1, q_2, q_3 = \"q_1\", \"q_2\", \"q_3\"\n# define M_1\nQ = {q_1, q_2, q_3}\nS = {0, 1}\nd = {\n    q_1 : { 0:q_1, 1:q_2 },\n    q_2 : { 0:q_1, 1:q_3 },\n    q_3 : { 0:q_3, 1:q_3 }\n}\nM_1 = (Q,S,d,q_1,{q_3})\nprint(M_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n({'q_3', 'q_1', 'q_2'}, {0, 1}, {'q_1': {0: 'q_1', 1: 'q_2'}, 'q_2': {0: 'q_1', 1: 'q_3'}, 'q_3': {0: 'q_3', 1: 'q_3'}}, 'q_1', {'q_3'})\n```\n:::\n:::\n\n\n## Strings/Languages\n\n-   A *string* is a **sequence** of letters $\\Sigma^n$\n-   A *language* is a set of *strings*.\n-   The empty string is zero length $\\Sigma^0$\n-   The empty language is the empty set $\\varnothing$\n\n:::{.fragment}\n*We note that the empty string is not in or related to the empty language*\n:::\n\n## Acceptance\n\n-   $M$ *accepts* string $w = w_1w_2\\ldots w_n$ if:\n\n:::{.fragment}\n$$\n\\forall w_i \\in \\Sigma : \\exists r_0r_1\\ldots r_n : \n$$\n:::\n\n\n:::{.fragment}\n\n$$\nr_0 = q_0 \\land \n$$\n\n:::\n\n\n:::{.fragment}\n\n$$\nr_n \\in F \\land \n$$\n\n:::\n\n\n:::{.fragment}\n\n$$\n\\forall i : r_i = \\delta(r_{i-1},w_i) \n$$\n\n:::\n\nDiagrams\n--------\n\nKripke Structures\n\nBüchi Automata\n\n*   Both (graphs) have a circles (nodes) and arrows (edges)\n    *   Kripke Structures label circles (nodes)\n    *   Büchi Automata label arrows (edges)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ : the states of _A_.\n*   _Σ_ : the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ : transition function.\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = { _q0, q1, q2_} in cyan\n*   _Σ_ : the alphabet of _A_.\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ : transition function.\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi2.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = { _q0, q1, q2_} in cyan\n*   _Σ_ = {_red, green, yellow_} in magenta\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ : transition function.\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi3.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = { _q0, q1, q2_} in cyan\n*   _Σ_ = {_red, green, yellow_} in magenta\n*   _δ_ : _Q_ × _Σ_ **→** _Q_ in blue\n    *   Take ((_q0, red_), _q0_) as `0R0`\n    *   _δ_ =`{0R0,0G1,1G1,1Y2,2Y2,2R0}`\n*   _q0_ ∈ _Q_ : the initial state of _A_\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi4.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = {_0, 1, 2_ } in cyan\n*   _Σ_ = {_R, G, Y_ } in magenta\n*   _δ_ = `{R0G1,G1Y2,Y2R0}` in blue\n*   _q0_ or _0_ : in orange\n*   **F** ⊆ _Q_ : the acceptance condition\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi5.png)\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = {_0, 1, 2_ } in cyan\n*   _Σ_ = {_R, G, Y_ } in magenta\n*   _δ_ = `{R0G1,G1Y2,Y2R0}` in blue\n*   _q0_ or _0_ in orange\n*   **F** = {_q0_} or {_0_} in black\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi5.png)\n\nSafety and Liveness\n-------------------\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nSafety\n------\n\n*   Some security properties are about bad things not happening:\n    *   **G****¬**_bad_\n    *   Term this \"safety\"\n*   If a Büchi Automata is a safety property...\n    *   If the bad things happens, the system is unrecoverable.\n    *   Therefore, any failures result from \"falling off\" the diagram.\n    *   Therefore, all states are accepting states (no failures based on ending).\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nSafety\n------\n\nThe **closure** of Büchi Automaton given by _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.  \n  \nThat is, _cl(A)_ is equivalent to _A_ if the set of accepting states **F** is expanded to include all of the states of _A_\n\n<\n\nA **safety property** is a property given by a Büchi Automaton _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } such that all traces accepted by _A_ are also accepted by its _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nSafety\n------\n\n*   This means, we can develop safety properties from arrows (edges), or from _δ_\n    *   We see that yellow is always preceded by green or yellow.\n    *   Yellow is never preceded by red.\n    *   So we can say that the bad thing is red with yellow next\n    *   **G****¬**(_red_∧**X**_yellow_ )\n    *   **G****¬**(_green_∧**X**_red_ )\n    *   **G****¬**(_yellow_∧**X**_green_ )\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nSafety\n------\n\nCould we argue that only **G****¬**(_green_∧**X**_red_ ) is a safety property?\n\n  \n\n15-20 min: In small groups, define the Büchi Automaton that captures \\*only\\* this safety property.\n\n  \n\nA diagram is sufficient, but think about _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n  \n\nBe prepared to demonstrate that you have created a safety property!\n\nSafety\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\nLiveness\n--------\n\n*   Some security properties are about good things happening someday:\n    *   **F**_good_\n    *   Term this \"liveness\"\n*   If a Büchi Automata is a liveness property...\n    *   No matter what happens, the system is recoverable.\n    *   Therefore, any failures result from not reaching accepting states.\n    *   Therefore, all states should have outgoing edges covering all letters of the trace alphabet.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLiveness\n--------\n\nThe **closure** of Büchi Automaton given by _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.  \n  \nThat is, _cl(A)_ is equivalent to _A_ if the set of accepting states **F** is expanded to include all of the states of _A_\n\n<\n\nA **liveness property** is a property given by a Büchi Automaton _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } such that _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ } accepts all possible traces in _Σ_ ω.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLiveness\n--------\n\n*   This means, we can study liveness properties by adding a self-loop with negation of all other outgoing edges to each automaton state.\n    *   We see that _q1_ has an outgoing edge labelled \"yellow\".\n    *   We add an edge from _q1_ to itself that is labelled \"not yellow\".\n*   As a convenience, we say the \"good thing\" is the light turning green\n    *   We mark _q1_ as the accepting state, since it is reached when the light turns green.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLiveness\n--------\n\nCould we argue that only **F**_green_ is a Liveness property?\n\n  \n\n10-15 min: In small groups, define the Büchi Automaton that captures \\*only\\* this liveness property.\n\n  \n\nA diagram is sufficient, but think about _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n  \n\nBe prepared to demonstrate that you have created a safety property!\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\n\nProperties\n----------\n\n\"I want to be able to access my savings but no one else.\"\n\n*   Safety properties are about bad things not happening:\n    *   **G****¬**_bad_\n    *   These are undefined transitions in Büchi automata\n    *   \"No one else may access my savings\"\n*   Liveness properties are about good things happening eventually:\n    *   **F**_good_\n    *   These are accepting states in Büchi automata\n    *   \"I want to be able to access my savings\"\n\nDiagrams\n--------\n\n_A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** }\n\n*   _Q_ = {_0, 1, 2_ } in cyan\n*   _Σ_ = {_R, G, Y_ } in magenta\n*   _δ_ = `{R0G1,G1Y2,Y2R0}` in blue\n*   _q0_ or _0_ in orange\n*   **F** = {_q0_} or {_0_} in black\n\nTraffic Light\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi5.png)\n\nSafe() and Live()\n-----------------\n\nWe now define `Safe():`\n\n`Safe(m)` excludes the \"bad thing\" for a Buchi automaton, which is attempting an undefined transition, because if such a \"bad thing\" happens at any point in the trace, the Buchi automaton will not accept that trace.\n\n... and `Live()`:\n\n`Live(m)` requires the \"good thing\" for a Buchi automaton, which is entering an accepting state infinitely often, because we require this \"good thing\" to happen for trace to be accepted.\n\nIntersection\n------------\n\nWe recall set theoretic intersection...\n\nIn set theory, the intersection of two sets _A_ and _B_, denoted by _A_ **∩**_B_ is the set containing all elements of _A_ that also belong to _B_\n\n... and we recall what properties are:\n\nA **trace property** is a set of traces.\n\nAnd now we make our claim:\n\n\"Given a Buchi automaton `m`, it is not difficult to construct Buchi automata `Safe(m)` and `Live(m)` such that `Safe(m)` specifies a safety property, `Live(m)` specifies a liveness property, and the prop- erty specified by `m` is the intersection of those specified by Safe(m) and Live(m).\"\n\nExample\n-------\n\nConsider the following Büchi automata over the alphabet of lower case letters:\n\n![](https://upload.wikimedia.org/wikipedia/commons/5/56/Automate_de_Buchi2.jpg?20180829053802)\n\nSafety means **G**_a_ **∨** _b_\n\n    Safe(m) = {\"a\", \"b\", \"aa\", \"ab\", \"ba\", \"bb\", \"aaa\", \"aab\", ... }\n\nLiveness means **G****F**_a_\n\n    Live(m) = {\"a\", \"aa\", \"ba\", \"ca\", \"da\", \"ea\", \"fa\", \"ga\", ... }\n\nThe intersection represents elements in both `Safe(m)` and `Live(m)`...\n\nExample\n-------\n\nSafety means **G**_a_ **∨** _b_\n\n    Safe(m) = {\"a\", \"b\", \"aa\", \"ab\", \"ba\", \"bb\", \"aaa\", \"aab\", ... }\n\nLiveness means **G****F**_a_\n\n    Live(m) = {\"a\", \"aa\", \"ba\", \"ca\", \"da\", \"ea\", \"fa\", \"ga\", ... }\n\nThe intersection represents elements in both `Safe(m)` and `Live(m)`...\n\n    m = {\"a\", \"b\", \"aa\", \"ba\", \"aaa\", \"aba\", \"baa\", \"bba\", ... }\n\nTo continue to advance our understanding of the distinction, we explore how to generate `Safe(m)` and `Live(m)`.\n\nSafe()\n------\n\nWe recall the definition of safety.\n\n`Safe(m)` excludes the \"bad thing\" for a Buchi automaton, which is attempting an undefined transition, because if such a \"bad thing\" happens at any point in the trace, the Buchi automaton will not accept that trace.\n\nWe recall the definition of closure.\n\nThe **closure** of Büchi Automaton given by _A_ ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is _cl(A)_ ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }.  \n  \nSo_cl(A)_ is equivalent to _A_ if the set of accepting states **F** is expanded to include all of the states of _A_.\n\nA core \"nicety\" of Büchi Automata is that **the safety property is the closure**.\n\nSafe()\n------\n\nA core \"nicety\" of Büchi Automata is that **the safety property is the closure**.\n\n`Safe(m)` = `cl(m)`  \n  \nThat is, for `m` ≔ {_Q_, _Σ_, _δ_, _q0_, **F** } is `cl(m)` ≔ {_Q_, _Σ_, _δ_, _q0_, _Q_ }\n\nThe closure simply allows any trace without an undefined transition (or \"bad thing\") to be accepted.\n\nLive()\n------\n\nWe recall the definition of liveness.\n\n`Live(m)` requires the \"good thing\" for a Buchi automaton, which is entering an accepting state infinitely often, because we require this \"good thing\" to happen for trace to be accepted.\n\nThink back to our example (emphasis added):\n\n\"Consider the following Büchi automata **over the alphabet of lower case letters**\"\n\n![](https://upload.wikimedia.org/wikipedia/commons/5/56/Automate_de_Buchi2.jpg?20180829053802)\n\nWhile safety is mostly about **F**, the accepting states or the double circles, liveness is mostly about _Σ_ = `{a, b, ?}`, the alphabet or the possible states of the trace (NOT the states of the automata) that form the labels on arrows.\n\nLive()\n------\n\nSo we define liveness relative to _Σ_. There most be no undefined transitions (that would be safety) so we require that any letter in _Σ_ has a defined transition at any point in time. ![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLive()\n------\n\nWith the traffic light, we ensured there were no undefined transitions using logical not \"**¬**\"\n\n  \n\nBut what does this logical not really do with respect to the alphabet?\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nLive()\n------\n\nLet's look back at our original _δ_ and _Σ_.\n\n*   _δ_ =`{0R0,0G1,1G1,1Y2,2Y2,2R0}`\n*   _Σ_ = {_R_, _G_, _Y_ }\n\nTo make a liveness property, we made sure that each of {_R_, _G_, _Y_ } had a defined place to go from each automata state. We added:\n\n*   _δlive(m)_ =`{0Y0,1R1,2G2}`\n\nBut this is ugly, let's look at a table\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nBefore Live()\n-------------\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/buchi.png)\n\n   \n\nTransition Letter\n\n_R_\n\n_G_\n\n_Y_\n\nInitial State\n\nNext State\n\n**_q0_**\n\n_q0_\n\n_q1_\n\n**UNDEFINED**\n\n_q1_\n\n**UNDEFINED**\n\n_q1_\n\n_q2_\n\n_q2_\n\n_q0_\n\n**UNDEFINED**\n\n_q2_\n\nWith Live()\n-----------\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\n   \n\nTransition Letter\n\n_R_\n\n_G_\n\n_Y_\n\nInitial State\n\nNext State\n\n**_q0_**\n\n_q0_\n\n_q1_\n\n_q0_\n\n_q1_\n\n_q1_\n\n_q1_\n\n_q2_\n\n_q2_\n\n_q0_\n\n_q2_\n\n_q2_\n\nProblem\n-------\n\nThis _δ_ doesn't define a traffic light!\n\n*   _δlive(m)_ =\n    \n        {0R0,0G1,\n         1G1,1Y2,\n         2Y2,2R0,\n         0Y0,1R1,2G2}\n    \n*   _Σ_ = {_R_, _G_, _Y_}\n\nWe need a way to preserve existing state transitions, while eliminating undefined transitions.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nTrap State\n----------\n\nIntroduce new state _qtrap_ or _qt_\n\n*   _δlive(m)_ =\n    \n        {0R0,0G1,\n         1G1,1Y2,\n         2Y2,2R0,\n         0Yt,1Rt,2Gt}\n    \n*   _Σ_ = {_R_, _G_, _Y_ }\n*   _Q_ = {_0_, _1_, _2_, _t_ }\n\nWe need a way to preserve existing state transitions, while eliminating undefined transitions.\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/trap.png)\n\nTrap State\n----------\n\nBut how does _Σ_ = {_R_, _G_, _Y_ } figure in?\n\n  \n\nA flashing red _F_ or out light _O_ can still be green in the future!\n\n  \n\nThe trap transition aren't fixed letters - they are the **the rest of the alphabet!**\n\n*   _δlive(m)_ =\n    \n        {0R0,0G1,\n         1G1,1Y2,\n         2Y2,2R0,\n         0*t,1*t,2*t}\n    \n*   _Σ_ = {_R_, _G_, _Y_, _F_, _O_, ... }\n\nLiveness\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nTrap State\n----------\n\n    \n\nTransition\n\nLetter\n\n_{R}_\n\n_{G}_\n\n_{Y}_\n\n_Σ_/{_R_, _G_, _Y_ }\n\nInitial State\n\nNext State\n\n**_q0_**\n\n_q0_\n\n_q1_\n\n_qt_\n\n_qt_\n\n_q1_\n\n_qt_\n\n_q1_\n\n_q2_\n\n_qt_\n\n_q2_\n\n_q0_\n\n_qt_\n\n_q2_\n\n_qt_\n\nLive()\n------\n\nWe recall the definition of safety.\n\n`Live(m)` requires the \"good thing\" for a Buchi automaton, which is entering an accepting state infinitely often, because we require this \"good thing\" to happen for trace to be accepted.\n\nSo in practice, we have\n\n`Live(m)` is `m` augmented by an accepting trap state _qt_ and new transition function _δlive(m)_ which is the transition function _δ_ extended so that it causes every undefined transition of `m` to put `Live(m)` in _qt_\n\nOverall\n-------\n\nMost Simple\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/live.png)\n\nMost Correct\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nWhy trap states\n---------------\n\nIn defense of the most correct version with trap.\n\n*   This trap state captures all safety failures.\n*   Anything going to trap is not in `Safe()`\n*   Likewise, anything in `Safe()` that is accepted, is \"green eventually\".\n\nThis gives \"safe and green or unsafe\".\n\nMost Correct\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nWhy trap states\n---------------\n\nThis gives \"safe and green or unsafe\".\n\n*   That is, it gives `m` and also something else - all unsafe traces.\n*   Recall: We use _Σ_ ω (upper case sigma raised to lower case omega) to denote infinite traces.\n*   So `Live(m)` = `m` **∪** _Σ ω_ / `Safe(m)`\n*   Say \"the liveness property is everything that is both safe and live, and everything that isn't safe.\"\n\nMost Correct\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\nIntersection\n------------\n\nSafe()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\n`cl(m)`\n\nLive()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\n`m` **∪** _Σω_ / `cl(m)`\n\nIntersection\n------------\n\nWe take the intersection of these two sets (of traces).\n\n*   `Live(m)`**∩**`Safe(m)`, that is\n    \n*   `cl(m)`**∩**`m`**∪**_Σω_/ `cl(m)`\n    \n\nWe consider:\n\n1.  Everything in `m` is in `cl(m)`, that is, `m`**⊂**`cl(m)`\n2.  Everything in `cl(m)` is in _Σω_, that is, `cl(m)`**⊂**_Σω_\n3.  Nothing in `m` is in _Σω_/ `cl(m)`, that is, `m`**∩**_Σω_/ `cl(m)`\\=_∅_\n\nLet's take a look.\n\nIntersection\n------------\n\n1.  Everything in `m` is in `cl(m)`, that is, `m`**⊂**`cl(m)`\n2.  Everything in `cl(m)` is in _Σω_, that is, `cl(m)`**⊂**_Σω_\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m1.png)\n\nIntersection\n------------\n\n1.  Everything in `m` is in `cl(m)`, that is, `m`**⊂**`cl(m)`\n2.  Nothing in `m` is in _Σω_/ `cl(m)`, that is, `m`**∩**_Σω_/`cl(m)`\\=_∅_\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m2.png)\n\nIntersection\n------------\n\n1.  Everything in `m` is in `cl(m)`\n2.  Everything in `m` is in `m`**∪**_Σω_/ `cl(m)`\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m1.png)\n\nIntersection\n------------\n\nNothing in `cl(m)` is in `m`**∪**_Σω_/ `cl(m)` without being in `m`\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m1.png)\n\nEverything in `m` is in `m`**∪**_Σω_/ `cl(m)` and in `cl(m)`\n\nIntersection\n------------\n\nSafe lights are yellow before red.\n\nLive lights are either (1) green someday, or (2) don't use yellow.\n\nSafe, live lights are (1) green someday, and (2) use yellow.\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/m3.png)\n\nWork time\n---------\n\nSafe()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/safe.png)\n\n`cl(m)`\n\nLive()\n\n![](https://cd-public.github.io/courses/old/secs24/slides/images/many.png)\n\n`m` **∪** _Σω_ / `cl(m)`\n\n",
    "supporting": [
      "logics_files"
    ],
    "filters": [],
    "includes": {}
  }
}