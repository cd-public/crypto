<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>heap_t</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-9884a2177d2957eae00b06e372949a78.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6143deb5822414b99d6193ead6da13dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">heap_t</h1>
            <p class="subtitle lead">HW 0x4.1: Due Fri, 08 Aug</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<style>
  * {
    background-repeat: no-repeat;
    background-attachment: fixed;
  }
</style>
<section id="review-show" class="level1">
<h1>Review&nbsp;<a class="btn btn-primary" data-bs-toggle="collapse" href="#review" role="button" aria-expanded="false" aria-controls="review">Show</a></h1>
<div id="review" class="collapse multi-collapse">
<section id="goal-implement-an-data-structure-based-sorting-algorithm." class="level3">
<h3 class="anchored" data-anchor-id="goal-implement-an-data-structure-based-sorting-algorithm.">Goal: Implement an data structure based sorting algorithm.</h3>
<div class="callout callout-style-default callout-note callout-titled" title="On Due Dates">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
On Due Dates
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>I am not allowed to make assignments due during finals.</li>
<li>However, I am supportive of “no excuse” late turn-ins up until the final project is due.</li>
</ul>
</div>
</div>
<ul>
<li>This is the first of two “data structures” assignments, implementing the “Merkle tree” of blockchain.</li>
<li>The data stored by the structure is untyped and the heap is provided only with its size.
<ul>
<li>The same is true of the provided comparison function.</li>
</ul></li>
<li>It is split over 3 files:
<ul>
<li><code>tester.c</code> which is an example of how some client could use <code>heap_t</code></li>
<li><code>heap_t.h</code> which the public API you will implement, as with <code>list_t</code>
<ul>
<li>You may not change any lines and must use the array implementation.</li>
<li>This is learning objective of the assignment.</li>
</ul></li>
<li><code>heap_t.c</code> where you have some freedom but will be implementing known algorithms.</li>
<li>Additionally, a Makefile is provided.</li>
</ul></li>
</ul>
</section>
</div>
</section>
<section id="heap_t-show" class="level1">
<h1>heap_t&nbsp;<a class="btn btn-primary" data-bs-toggle="collapse" href="#heaper" role="button" aria-expanded="false" aria-controls="heaper">Show</a></h1>
<div id="heaper" class="collapse multi-collapse">
<section id="initialize-or-construct-a-new-heap." class="level2">
<h2 class="anchored" data-anchor-id="initialize-or-construct-a-new-heap.">Initialize or construct a new heap.</h2>
<ul>
<li>You may not change the type but may change the names.</li>
<li>Implement a max heap, wherein the maximum element per the comparison function called <code>gt</code> below is in the initial position.</li>
<li>You may 1-index or 0-index.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>heap_t heap<span class="op">(</span><span class="dt">size_t</span> ele_size<span class="op">,</span> <span class="dt">bool</span> <span class="op">(*</span>gt<span class="op">)(</span><span class="dt">void</span> <span class="op">*,</span> <span class="dt">void</span> <span class="op">*));</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>I stack allocated my heap, which are welcome but not required to do.</li>
<li>My initial heap explicitly contained zero elements.</li>
</ul>
</section>
<section id="the-heap-struct" class="level2">
<h2 class="anchored" data-anchor-id="the-heap-struct">The Heap Struct</h2>
<ul>
<li>I am requiring the usage of a single internal array, a function pointer, and something to track the size of elements in the array.</li>
<li>You do not have to maintain <code>capacity</code> and there is no graceful way to avoiding maintaining <code>num_eles</code> (though non-graceful is fine) but it is probably easier to view them as required.</li>
</ul>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> heap_struct <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* These may be changed, but probably are okay */</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> ele_size<span class="op">;</span> <span class="co">/* size of element */</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> num_eles<span class="op">;</span> <span class="co">/* number of elements */</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> capacity<span class="op">;</span> <span class="co">/* current capacity of the heap */</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="op">(*</span>gt<span class="op">)(</span><span class="dt">void</span> <span class="op">*,</span> <span class="dt">void</span> <span class="op">*);</span> <span class="co">/* for "greater than" */</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* You must store all data elements s.t. reachable from 1 pointer */</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>eles<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> heap_t<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="explanation" class="level2">
<h2 class="anchored" data-anchor-id="explanation">Explanation</h2>
<ul>
<li><code>ele_size</code>
<ul>
<li>This heap implementation allows storage of elements of any <code>size_t</code> specifiable size.</li>
<li>For example, it could store hash digests, <code>4096_t</code>, fixed length strengths, or <code>uint24_t</code>’s.</li>
<li>This is a helpful exercise in reflecting on types and sizes.</li>
</ul></li>
<li><code>num_eles</code>
<ul>
<li>A heap must track its size to know where to place the next element on an insert operation.</li>
</ul></li>
<li><code>capacity</code>
<ul>
<li>You are not required to keep an internal array precisely large enough to store all elements.</li>
<li>I only change the size of my internal array by doubling, a common rule of thumb.</li>
<li>You can change the size of an array with novel malloc, a memcpy, and a free, or</li>
<li>You can change the size of an array with <a href="https://www.man7.org/linux/man-pages/man3/realloc.3p.html"><code>realloc</code></a>, which is preferred but was not covered in lecture.</li>
<li>You are not required to have a distinct <code>num_eles</code> and <code>capacity</code>, but are sufficiently encouraged to do so I made both fields mandatory.</li>
</ul></li>
<li><code>gt</code>
<ul>
<li>This is just the comparison function, without which the sorting regime of the heap is unclear and should be maintained within the data structure.</li>
<li>I separately wanted you to see a struct with a function in it!</li>
</ul></li>
<li><code>eles</code>
<ul>
<li>This is the entries of the heap.</li>
<li>It must satisfy the heap property of the element at the initial location being the maximum.</li>
<li>All elements must be stored linearly in a single contigious memory block.</li>
<li>You may index to zero <code>0</code> or one <code>1</code> at your discretion, I used zero indexing which seemed unexpectedly easier when writing the code.</li>
</ul></li>
</ul>
</section>
</div>
</section>
<section id="insert-show" class="level1">
<h1>insert&nbsp;<a class="btn btn-primary" data-bs-toggle="collapse" href="#header" role="button" aria-expanded="false" aria-controls="header">Show</a></h1>
<div id="header" class="collapse multi-collapse">
<section id="insert-an-element" class="level2">
<h2 class="anchored" data-anchor-id="insert-an-element">Insert an element</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> insert<span class="op">(</span>heap_t <span class="op">*</span>heap<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>ele_ptr<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Given the pointer to some element of appropriate size to be stored in the heap, place it in the first available location in the heap array then perform the heapify operation.</li>
<li>Consult the slides if you are unclear on what heapify is.</li>
</ul>
</section>
</div>
</section>
<section id="maxpop-show" class="level1">
<h1>maxpop&nbsp;<a class="btn btn-primary" data-bs-toggle="collapse" href="#maxpop" role="button" aria-expanded="false" aria-controls="maxpop">Show</a></h1>
<div id="maxpop" class="collapse multi-collapse">
<section id="pop-the-maximal-element" class="level2">
<h2 class="anchored" data-anchor-id="pop-the-maximal-element">Pop the maximal element</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="op">*</span>maxpop<span class="op">(</span>heap_t <span class="op">*</span>heap<span class="op">);</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>This returns a <em>heap allocated</em> copy of the former maximum value in the heap.</li>
<li>Separately, these element is removed from the heap.</li>
<li>Finally, the heap is rearranged to maintain the heap property using a “SiftDown” operation.</li>
</ul>
</section>
<section id="sift-down" class="level2">
<h2 class="anchored" data-anchor-id="sift-down">Sift Down</h2>
<ul>
<li>After a <code>maxpop</code>, the initial index - zero or one - is vacant.</li>
<li>Overwrite this value at this location with the last element in the heap array - the rightmost leaf in the last layer.</li>
<li>Compare this value, now at the initial position, which each of its children.</li>
<li>Swap it with the greatest of its children.</li>
<li>Continue to swap, or “sift down”, this value until it is either in a leaf position or is greater than both of its children.</li>
</ul>
</section>
<section id="visual-demo" class="level2">
<h2 class="anchored" data-anchor-id="visual-demo">Visual Demo</h2>
<ul>
<li>Begin with the default heap.</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="dv">224</span><span class="op">,</span> <span class="dv">160</span><span class="op">,</span> <span class="dv">192</span><span class="op">,</span> <span class="dv">64</span><span class="op">,</span> <span class="dv">96</span><span class="op">,</span> <span class="dv">128</span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell" data-fig-width="45%" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 197.04 233.13" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 229.13)">
<title>finite_automata</title>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<ellipse fill="none" stroke="#32fbe2" cx="128.52" cy="-199.61" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="128.52" y="-195.41" font-family="Times,serif" font-size="14.00" fill="#32fbe2">224</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<ellipse fill="none" stroke="#32fbe2" cx="94.52" cy="-112.57" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="94.52" y="-108.37" font-family="Times,serif" font-size="14.00" fill="#32fbe2">160</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="#32fbe2" d="M119.23,-175.37C115.6,-166.3 111.38,-155.74 107.47,-145.94"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="110.65,-144.47 103.68,-136.48 104.15,-147.07 110.65,-144.47"></polygon>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<ellipse fill="none" stroke="#32fbe2" cx="163.52" cy="-112.57" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="163.52" y="-108.37" font-family="Times,serif" font-size="14.00" fill="#32fbe2">192</text>
</g>
<!-- 1&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>1-&gt;3</title>
<path fill="none" stroke="#32fbe2" d="M137.9,-175.82C141.71,-166.57 146.17,-155.73 150.3,-145.7"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="153.55,-147 154.12,-136.42 147.07,-144.33 153.55,-147"></polygon>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<ellipse fill="none" stroke="#32fbe2" cx="25.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="25.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">064</text>
</g>
<!-- 2&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>2-&gt;4</title>
<path fill="none" stroke="#32fbe2" d="M78.86,-92.27C69.6,-80.85 57.72,-66.21 47.53,-53.65"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="50.14,-51.3 41.12,-45.74 44.7,-55.71 50.14,-51.3"></polygon>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<ellipse fill="none" stroke="#32fbe2" cx="94.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="94.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">096</text>
</g>
<!-- 2&#45;&gt;5 -->
<g id="edge4" class="edge">
<title>2-&gt;5</title>
<path fill="none" stroke="#32fbe2" d="M94.52,-86.97C94.52,-78.95 94.52,-69.88 94.52,-61.26"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="98.02,-61.06 94.52,-51.06 91.02,-61.06 98.02,-61.06"></polygon>
</g>
<!-- 6 -->
<g id="node6" class="node">
<title>6</title>
<ellipse fill="none" stroke="#32fbe2" cx="163.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="163.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">128</text>
</g>
<!-- 3&#45;&gt;6 -->
<g id="edge5" class="edge">
<title>3-&gt;6</title>
<path fill="none" stroke="#32fbe2" d="M163.52,-86.97C163.52,-78.95 163.52,-69.88 163.52,-61.26"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="167.02,-61.06 163.52,-51.06 160.02,-61.06 167.02,-61.06"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<ul>
<li>Heap allocate a space for <code>224</code> to be returned to the client (and freed by the client).</li>
<li>Overwrite 224 with the rightmost leaf of the final layer.
<ul>
<li>In this case, I also just leave this value in the array (why not?)</li>
<li>I just won’t look at it due to it being outside of the number of elements, and it will be freed eventually.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="dv">128</span><span class="op">,</span> <span class="dv">160</span><span class="op">,</span> <span class="dv">192</span><span class="op">,</span> <span class="dv">64</span><span class="op">,</span> <span class="dv">96</span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell" data-fig-width="45%" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 162.04 233.13" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 229.13)">
<title>finite_automata</title>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<ellipse fill="none" stroke="#32fbe2" cx="93.52" cy="-199.61" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="93.52" y="-195.41" font-family="Times,serif" font-size="14.00" fill="#32fbe2">128</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<ellipse fill="none" stroke="#32fbe2" cx="59.52" cy="-112.57" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="59.52" y="-108.37" font-family="Times,serif" font-size="14.00" fill="#32fbe2">160</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="#32fbe2" d="M84.23,-175.37C80.6,-166.3 76.38,-155.74 72.47,-145.94"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="75.65,-144.47 68.68,-136.48 69.15,-147.07 75.65,-144.47"></polygon>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<ellipse fill="none" stroke="#32fbe2" cx="128.52" cy="-112.57" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="128.52" y="-108.37" font-family="Times,serif" font-size="14.00" fill="#32fbe2">192</text>
</g>
<!-- 1&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>1-&gt;3</title>
<path fill="none" stroke="#32fbe2" d="M102.9,-175.82C106.71,-166.57 111.17,-155.73 115.3,-145.7"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="118.55,-147 119.12,-136.42 112.07,-144.33 118.55,-147"></polygon>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<ellipse fill="none" stroke="#32fbe2" cx="25.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="25.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">064</text>
</g>
<!-- 2&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>2-&gt;4</title>
<path fill="none" stroke="#32fbe2" d="M50.23,-88.33C46.6,-79.25 42.38,-68.69 38.47,-58.9"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="41.65,-57.42 34.68,-49.44 35.15,-60.02 41.65,-57.42"></polygon>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<ellipse fill="none" stroke="#32fbe2" cx="94.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="94.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">096</text>
</g>
<!-- 2&#45;&gt;5 -->
<g id="edge4" class="edge">
<title>2-&gt;5</title>
<path fill="none" stroke="#32fbe2" d="M68.9,-88.78C72.71,-79.53 77.17,-68.68 81.3,-58.66"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="84.55,-59.95 85.12,-49.38 78.07,-57.29 84.55,-59.95"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<ul>
<li>I check both of <code>128</code>s children, find the maximum, and compare that to <code>128</code>
<ul>
<li>The maximum is <code>192</code></li>
<li>That is greater than <code>128</code></li>
<li>So, swap.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="dv">192</span><span class="op">,</span> <span class="dv">160</span><span class="op">,</span> <span class="dv">128</span><span class="op">,</span> <span class="dv">64</span><span class="op">,</span> <span class="dv">96</span><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell" data-fig-width="45%" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<svg width="NaN" height="480" viewbox="0.00 0.00 162.04 233.13" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" style="; max-width: none; max-height: none">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 229.13)">
<title>finite_automata</title>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<ellipse fill="none" stroke="#32fbe2" cx="93.52" cy="-199.61" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="93.52" y="-195.41" font-family="Times,serif" font-size="14.00" fill="#32fbe2">192</text>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<ellipse fill="none" stroke="#32fbe2" cx="59.52" cy="-112.57" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="59.52" y="-108.37" font-family="Times,serif" font-size="14.00" fill="#32fbe2">160</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge1" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="#32fbe2" d="M84.23,-175.37C80.6,-166.3 76.38,-155.74 72.47,-145.94"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="75.65,-144.47 68.68,-136.48 69.15,-147.07 75.65,-144.47"></polygon>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<ellipse fill="none" stroke="#32fbe2" cx="128.52" cy="-112.57" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="128.52" y="-108.37" font-family="Times,serif" font-size="14.00" fill="#32fbe2">128</text>
</g>
<!-- 1&#45;&gt;3 -->
<g id="edge2" class="edge">
<title>1-&gt;3</title>
<path fill="none" stroke="#32fbe2" d="M102.9,-175.82C106.71,-166.57 111.17,-155.73 115.3,-145.7"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="118.55,-147 119.12,-136.42 112.07,-144.33 118.55,-147"></polygon>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<ellipse fill="none" stroke="#32fbe2" cx="25.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="25.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">064</text>
</g>
<!-- 2&#45;&gt;4 -->
<g id="edge3" class="edge">
<title>2-&gt;4</title>
<path fill="none" stroke="#32fbe2" d="M50.23,-88.33C46.6,-79.25 42.38,-68.69 38.47,-58.9"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="41.65,-57.42 34.68,-49.44 35.15,-60.02 41.65,-57.42"></polygon>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<ellipse fill="none" stroke="#32fbe2" cx="94.52" cy="-25.52" rx="25.54" ry="25.54"></ellipse>
<text text-anchor="middle" x="94.52" y="-21.32" font-family="Times,serif" font-size="14.00" fill="#32fbe2">096</text>
</g>
<!-- 2&#45;&gt;5 -->
<g id="edge4" class="edge">
<title>2-&gt;5</title>
<path fill="none" stroke="#32fbe2" d="M68.9,-88.78C72.71,-79.53 77.17,-68.68 81.3,-58.66"></path>
<polygon fill="#32fbe2" stroke="#32fbe2" points="84.55,-59.95 85.12,-49.38 78.07,-57.29 84.55,-59.95"></polygon>
</g>
</g>
</svg>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<ul>
<li>If <code>128</code> had child nodes, I would recurse, but in the case the process terminates here as the <code>128</code> is a leaf.</li>
<li>We notice that the heap property is satisfied - all parent nodes are greater than all of their child nodes.</li>
</ul>
</section>
</div>
</section>
<section id="tester-show" class="level1">
<h1>Tester&nbsp;<a class="btn btn-primary" data-bs-toggle="collapse" href="#tester" role="button" aria-expanded="false" aria-controls="tester">Show</a></h1>
<div id="tester" class="collapse multi-collapse">
<section id="novel-tester" class="level2">
<h2 class="anchored" data-anchor-id="novel-tester">Novel Tester</h2>
<ul>
<li>Versus other testers this term, I wanted to provide a more concrete file that actually used the heap_t, performed operations, and issued outputs as print statements.</li>
<li>I hope that tester is self-documenting, but would love to hear your questions!</li>
</ul>
<iframe width="100%" height="500em" src="https://cd-public.github.io/calvinism/?uri=https://raw.githubusercontent.com/cd-c89/crypto/refs/heads/main/heap_t/tester.c">
</iframe>
<ul>
<li>For reference, here is <code>heap_t.h</code></li>
</ul>
<iframe width="100%" height="200em" src="https://cd-public.github.io/calvinism/?uri=https://raw.githubusercontent.com/cd-c89/crypto/refs/heads/main/heap_t/heap_t.h">
</iframe>
</section>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>